[{"title":"程序员到底能不能干到30?","date":"2017-04-24T08:43:56.000Z","path":"2017/04/24/程序员到底能不能干到30/","text":"程序员为什么高薪？从经济学上来说是因为稀缺性！但是现在世界上软件行业的从业者并不在少数，从这个角度来说，程序员并不稀缺，但换个角度，程序员这个行业的薪资差距却有如云泥之别，为什么？ 在回答这个问题前，先谈一个前段时间让我感到职业生涯恐慌的事件，华为被爆出开除年龄大于34的员工，当时不禁算了算自己年龄，如果自己就职于华为，那么也快到了被开除的年纪了，刚工作时和许多之前不同专业的同学聊天时，他们也总会时不时劝我，别看你现在赚的比我多，程序员是吃青春饭的，干不过30岁，我现在虽然赚的少，可是我稳定，你应该考虑转行之类的云云，说句实话，以前在听到这些时，我的心里多少还是有一些恐慌的，因为我实在想不出，那时的自己出去除了写代码，还能干啥？ 正如马云谈实体经济的一句话：“不是实体经济不行了，而是你们家的实体经济不行了！” 同理，不是30岁的程序员不行了，而是你不行了。 软件行业之所以高薪，是因为这个行业技术更新发展之快，远超其他普通行业，在这个行业，技术几乎每五年就翻新一轮，这带来一个结果，就是在这个行业每一位从业者，其实，都有一个统一的别称：学生！ 经济学十大定理之一，选择之后必有代价，我们选择这个行业，享受了它带来相比于其他大多数行业的高薪酬，就该承受与之而来的不断学习，不要等到掉队那天，不自己反省自己的不作为，反而给这个行业贴上不该有的标签，对于这种人，其实任何一个需要不断学习的行业，估计都干不过30岁，而那些哪怕入门很艰苦，但学成不需要在学习，吃老本的行业，请放心，它一定是低薪酬的。即使它开始一段时间高薪，也不可持久。 学习的意义是什么？我想借用一句自己很喜欢话来说明： “不是说学习本身特了不起，而是学习这个行为意味着你没有完全认同于这个现世和现实，你还有追求，还在奋斗，你还有不满，你还在寻找另一种可能性，另一种生活方式”也曾经像许多人一样幻想过，如果自己能像武侠小说中主人公一样，有一个德高望重的前辈，把自己的本领毫无保留的倾囊相授，让自己一跃成为技术大牛！可是现实和武侠小说最大的区别就是，这样的前辈有，也愿意毫无保留倾囊相授！但是自己却领悟不了！这是何等的绝望？但这确是铁铮铮的现实！ 比如高德纳老爷子的《计算机程序设计艺术》，以高老爷子在计算机中的地位以及知识存量来说，可以说很难有出其右者，绝对可以称的上是德高望重，而这部著作，以老爷子现在的高寿，估计绝对是把这本书当做垫棺之作，倾注了毕生所学之精华，绝对可以说是倾囊相授，可是我们当中又有几人能够完全领悟其中的至理？ 我想这便是读书意义了吧！读书(除去闲书)的好处之一便是可以借比自己牛的人但还可以勉强理解的视角，去看待许多自己现阶段不可能遇到，或者经常忽略的问题！去给自己大脑的操作系统升级！ 而另一个好处就是，我们不是总有机会和比自己牛逼的人一起共事，所以读书就是我们和那些比我们牛逼的人学习和交流的途径，当然不止有读书这一条路，在软件这个行业，还有一条更好的选择就是看源码！ 程序员们经常戏称自己为码农，做为程序员之间的幽默确实挺好，但是在自己内心，我一直把自己定位成为一个职业人。 大前沿一在他的《专业主义》中，对职业人有过这么一段论述： “对上帝发誓，以此为职业的人！”在这个信仰缺失的年代，而且是东方人，对上帝的几乎没有什么敬畏之心，其实我想说这里的上帝并非传统意义上圣经中的耶稣，而是自己内心中的本我！它是我们内心中最原始的渴望，不需要任何外力的监督，自然而然产生的一种本能！ 当然，做到这点很难，但是却不是不可以锻炼后天形成，这是一种对自己所从事职业的荣誉感，借用猫腻小说《将夜》中宁缺师傅颜瑟的一段话： “修行首重心性，在于敢想敢认，长路漫漫，你自己若都不相信自己能够走到最后，你怎么迈过修行路上那些艰难奇崛的险峰？越优秀的修行者越自信，而最优秀的那些修行者必然自信到极夸张的境界，大概也就是你所说的自恋。”虽然这是本网络小说，可读这本书，唯独这句对我的感触最大，记忆也最深刻，回到现实中，若不对自己所从事的行业报以极高的荣誉感，认同感，又岂能在自己的行业内有所建树？可以说我们是极致自恋，但这种职业人的精神，反过来却使我们在艰难中不断前行！如果你只是抱着某个行业高薪酬，好找工作，内心对这个行业始终充满不屑，那几乎可以肯定，你在这个行业终走不长远！ 罗振宇的节目中曾经有一期，论述过对学习的定义：他说读书有三个区域：舒适区、学习区和恐慌区，其中学习区又称为：逃离舒适区！但是舒适区其实是我们人类的本能，我们太习惯重复我们自己，而错过了许多进步的机会！这或许就是牛人之所以牛，而我们现在却一直平庸的原因！ 我工作已经四年多了，见过的程序员几乎没有一个愿意逃离自己学习的舒适区，总是在不断的重复着自己之前的技术！积累着使用这些技术的所谓经验，但是他们忘了，在这个行业，技术的迭代速度之高，有可能过一年，你所积累的经验就将一文不值，而那时的你，学习能力和性价比又如何和刚毕业的大学生比？我想，这便是华为开除34岁以上那批程序员的真实写照。在爆出华为开除员工消息后，我偶然在微信公众号中看到一位华为员工写的微文《华为之恶》，里面详尽叙述了华为是如何将员工当成螺丝钉用的，虽然我认同这篇文章部分观点，但却决不赞同他的结论！ 一个人的职业生涯，一般要远超一个公司的寿命，这其实给我们选择公司提供了一个指明灯，对于职业人来说，在选择工作时，薪水的丰厚是放在第二位的，而自己的职业发展是第一位，当然，我必须承认现实有时比较残忍，在这种情况下，我们其实可以先委屈自己一年，但在这一年绝对不要放弃自己的进步，可以抽一定时间自学，不让自己的技术差距平均水准太远，一年后相信你绝对有一定的经济基础和经验可以跳槽！诚然，这对任何人来说都是一个需要勇气才能做出的决定，但这也是你成为职业人，必须要走的道路，向华为这样的公司，虽然它剥夺了你职业生涯的发展，可同时也给予了你超越一般程序员的薪资，你既然没有选择离职，证明你也认可这种协议，等同于你愿意用自己以后的职业生涯去换前几年高于一般同龄人的薪资，那最后被开除了，又有何好抱怨？还是引用经济学的那句话：“选择之后，必有代价！”，太多的人只愿意接受选择过后，所带来的好处，而不愿意承担它所带来的后果！ 相较于华为，其实最不可容忍的，是自己葬送自己的职业生涯，但不幸的是，大多数程序员都是这么干的，我见过太多只愿意重复做自己熟悉东西的程序员，他们对外来的一切新技术都抱有本能排斥，与其说害怕学习新东西，倒不如说是懒！或是假勤奋，在公司我团队有3个刚毕业的大学生，本来打算自己去培训他们，让他们在技术上少走一些弯路，可是尝试过几次后，我彻底放弃了自己这个想法，你永远无法叫醒一个装睡的人，对于那些不想学习的，觉得只要完成工作，单位每月按时发工资就行，虽然他们工作也很辛苦，几乎天天加班，但却根本得不到应该有的回报！ 由此，我自己领悟了一个道理，在软件这个行业不存在教会徒弟，饿死师傅的问题，对于那些渴望进步的职业人，即使你不告诉他们，他们也迟早也会知道，而对于那些不愿意去进步的，你即使倾囊相授，掏心掏肺，也不会有一丝效果。所以大胆的去分享自己的所学、所思、所悟吧！毕竟我们都是一群有点自傲的孤独者！在这个大多数人都信仰“老板给多钱，我就干多钱活”的时代，我们承受了太多人的不理解，但我相信，时间会给我们最公正的答案！ 我对自己的要求是，在可能条件下，强迫自己用已经验证可靠的新技术去完成工作，对自己编码的要求是，相同的代码，绝不写第二遍，即使第二遍只是命名比第一遍规范一点。 时刻在内心告诫自己，小心被昨天自己的经验所束缚，佛门三障之一称之为：所知障！我在技术上对它的认识，还比较浅薄，总结一下就是“一次偶然的成功，比一次必然的失败更可怕！”。在以前的工作中，我不止一次遇到，最终被自己谷歌百度解决掉的问题，但是有一些第二次遇到，用之前相同的做法，却不能如前一次解决。而往往只有在第二次不能解决时，我才对这个问题有比较深入的研究和认识，引申而来，在技术中我们见过太多的理所应当，而不去探究它的本源，记得上学时，教我们编程的老师，有时候教我们时就会说：”这是固定写法，你这么写就对了“。当然我不是让大家去质疑一切知识本身，而是想告诉大家，在解决或者设计一个问题解法时，一定要注意，避免陷入自己的所知障，敢于打破自己以前的思维定式，做到这点很难！但每一次打破，就意味着你自己的进步！ 下面说说自己的学习方法吧！以前自己的学习方法就是买书，死磕，由于前期自己的知识存量不足，看不下去，就强迫自己去记笔记，说好听是在记笔记，说不好听就是在抄书，因为只有在这种情况下我的精神才能高度集中，渐渐也就爱上这种学习模式！ 当有了一定基础之后，我自己记笔记就少了，基本上都是花时间去迅速看，了解更多知识！ 第三个阶段，也是现在处在的阶段，我重新去审视了自己以前的学习方法，以及学到的知识，带着解决一个具体问题和批判的角度去重读一些知识点。最新成就是带着质疑自己看源码研究整理了部分的Java基础，看了Spring IOC核心的代码！ 其实在这里我最想说的不是自己的学习方法，其实每个人都有自己的学习方法，没有最好的方法，任何人也无法说你的学习方法是否是正确的，但只有你自己开始行动，开始不断的去积累，你就会总结出自己独有的学习方法，或许刚开始的方法是最笨的，可是没有之前的笨方法，你就不会在重复一段时间后，去找到更好的，与其纠结什么样的学习方法好，还不如现在就开始学，如果你还是要问，什么样的学习方法好？我会回答你，自己悟出来的最好！ 一般我自己学一门知识，会买至少与这个知识相关的两本书，比如，我最近在看网络相关的内容，我买了图灵的《网络是怎样链接的》和《计算机网络：自顶向下方法》两本，前一本比较易懂而后者相对比较难点，一般我会把前一本看到大概一半的位置，再去看第二本，这样我其实有了第一本浅显的认识，看起来能比较轻松点，第二本会看到自己看不太懂的章节，在返回来看第一本，这时我会发现第一本内容对我来说简直太简单了，一般这次会一口气读完第一本，然后在回第二本！有时自己学习同一个技术甚至会买5本或者更多，因为每个作者的认知和思路不同，对同一问题表述还是有一定差异的，有助于我理解比较难理解的一些概念，同时，又能相互印证，其实还是发现有很多书，在同一个知识点，表述上有所欠缺或不一致的情况（有时和翻译本身和作者理解有关）。 而下一个阶段就是质疑了，孟子说过：”尽信书，而不如无书！“！学姐也不止一次说：”自己越来越不迷信权威了！“ 而到这步，其实我们就培养了自己独立的认知，质疑哪怕被冠以权威的东西。这能让我们更容易看清技术的本质！不在被一些技术广告忽悠！在这里我引用《Scala函数式编程》作者的一句相类似的话来表述自己的想法： ”没有那个现有的库是权威的，或不需要再去推敲的，哪怕它们都是专家们设计的，还冠以”标准“的名头。很多库都存在一些随意的设计选择，尽管大多都是无心的。去重新审视那些已存在于设计库中的基本假设，从不同的角度发现别人从未想过的问题“既然提到图灵的学姐，这里就多说两句，在图灵社区与学姐结识，其实是一件偶然，当第一次得知学姐时，自己多少是有点不服气的，现在看来当时的自己还是很傲娇的说，可是逐渐熟悉后，我不得不承认，他高出我太多，可能我尽毕生之力，也赶不上他的步伐，他值得我发自心底的尊重，我是一个对技术很自傲的人，所以不存在刻意逢迎。是真不如也！说赶不上是因为，我在进步的时候，他也在进步，而且进步速度绝对要比我快！就好比，你如果天赋和Linus一样，但只要你不是小学时就开始编程，而是稍晚的时候。你是很难在技术上超越他的，这是真正的起跑线，每一个职业人一旦认清自己，开始启程，一般后跑的就只有仰望！而无法超越，无他！这个纬度是时间决定的。是很难绕过的，除非天赋比他高不少，或是他中间停止了职业生涯的前进！ 但借用王安石《游褒禅山记》所说的： ” 然力足以至焉， 于人为可讥， 而在己为有悔； 尽吾志也而不能至者， 可以无悔矣， 其孰能讥之乎？“虽不能至，吾心向往之！如果因为不能超越而不去努力，只会让更多的人超越自己！况且，职业人首先对自己负责，根本没必要去羡慕别人！追求更好的自己就好！ 由于在学网络这块知识，最近一直在研究林沛满的《Wireshark网络分析就这么简单》从我现在对学姐知识体系的浅见，他现在的编程技巧，超越了许多一般的程序员，下阶段若想在进一步成为《Wireshark网络分析就这么简单》这本书提及的Patrick那种大神的话，应该从更多元的角度去了解技术，在生产环境中任何一个问题产生，几乎不太可能是单一的，打一个比方，你代码写的很优雅，线上出现了问题，可能是网络的也可能是JVM本身的还有可能是发布环境中操作系统内部的一些bug，导致你的程序出现偶然不可重复原因异常，而这时，要定位并解决这种问题，就必须要求自己有多元化的知识结构，因为现今计算机技术本身就是一层一层技术的堆叠，我们在做好自己本身那块的同时，也要了解其他模块的设计理念以及局限性！当然这是我读这本书时一些粗浅看法和建议！仅供参考！","tags":[{"name":"日常记录","slug":"日常记录","permalink":"https://koala99.github.io/tags/日常记录/"},{"name":"程序员","slug":"程序员","permalink":"https://koala99.github.io/tags/程序员/"}]},{"title":"cuda的通信模型","date":"2017-03-03T05:53:53.000Z","path":"2017/03/03/cuda的通信模型/","text":"最近自己的深度学习工作站已经搭起。开始学习cuda。 udacity上课程 cs344cuda根据不同的memory映射方式，我们将task分为以下几种类型：Map, Gather, Scatter, Stencil, transpose. Map: one input - one outputGather: several input - one outpute.g image blur by averageScatter: one input - several outpute.g add a value to its neighbors(因为每个thread 将结果scatter到各个memory，所以叫scatter)stencil: 对input中的每一个位置，stencil input：该点的neighborhood stencil output：该点value e.g image blur by average 这样也可以看出，stencil和gather很像，其实stencil是gather的一种，只不过stencil要求input必须是neighborhood而且对input的每一个元素都要操作 transposeinput：matrix Moutput: M^T","tags":[{"name":"并行计算","slug":"并行计算","permalink":"https://koala99.github.io/tags/并行计算/"},{"name":"cuda","slug":"cuda","permalink":"https://koala99.github.io/tags/cuda/"}]},{"title":"ios 开发小结","date":"2016-09-20T13:54:34.000Z","path":"2016/09/20/ios-开发小结/","text":"很早就接触swift了，之前虽然写过一些简单的demo，但还没系统性完成一个商业app。之前开发完了公司的安卓版产品，没有ios，自己就承担开发ios的版本，算下来，时间比安卓开发稍微长一点，考虑到swift 3版本升级，造成一些库的兼容处理，总体时间上跟安卓开发时间差不多。这里就介绍一些自己用到的一些库。首先是布局方面，ios开发的布局，自己真的很不喜欢，虽然提供了storyboard这样的可视化拖拉，这边自己都是做autolayout,使用的库是Snapkit,自己通过纯代码来实现布局。虽然代码量大，但是写起来比较熟。网络请求之前用原生的来写，做json解析，真的挺麻烦的，后来采用了SwiftHTTP,使用简单。返回数据这边都做了序列化操作，ios中这边采用了ObjectMapper，它来做实体类的序列化，挺方便的。考虑到我们安卓中常常用到的事务总栈eventbus，swift方面也有对应的实现，基于notification来做的封装。 SwiftEventBus 。使用方法也与eventbus类似。一些图像的异步加载，离线缓存，我这边采用的是功能强大的 HanekeSwift ,它的作用远远不止这些。总体而言，因为app上没有涉及太多的复杂功能点，开发起来很顺利，ios的开发架构也跟安卓一致，最大的变数就是swift这本语言，2.0到3.0变化还有有些大的，当然，coder必须适应这些变化，不断学习。","tags":[{"name":"ios","slug":"ios","permalink":"https://koala99.github.io/tags/ios/"},{"name":"swift","slug":"swift","permalink":"https://koala99.github.io/tags/swift/"}]},{"title":"swift 3.0之后的一些变化","date":"2016-09-11T13:47:32.000Z","path":"2016/09/11/swift-3-0之后的一些变化/","text":"由于之前项目都是swift2写的，现在都得做升级，更新到swift3，这边就做下记录。 CGPointMake -> CGPoint let point = CGPoint(x: 0,y :0) // x和y的值可以是CGFloat, Double, Int CGSizeMake -> CGSize let size = CGSize(width: 100, height: 100) // width和height的值可以是CGFloat, Double, Int CGRectMake -> CGRect 用CGPoint和CGSize来构建 let rect = CGRect(origin: CGPoint(x: 0,y :0), size: CGSize(width: 100, height: 100)) 用CGFloat，Double和Int值构建 let rect = CGRect(x: 0, y: 0, width: 100, height: 100) // 参数类型可以为CGFloat, Double, Int CGRectZero->CGRect.zero & CGPointZero -> CGPoint.zero let size = CGSize.zero // width = 0, height = 0 let point = CGPoint.zero // x = 0, y = 0，等同于CGPointZero let rect = CGRect.zero // 等同与 CGRectZero","tags":[{"name":"ios,swift","slug":"ios-swift","permalink":"https://koala99.github.io/tags/ios-swift/"}]},{"title":"cmake配置","date":"2016-05-20T07:52:53.000Z","path":"2016/05/20/cmake配置/","text":"之前在mac上，开发c++，一向都是用qt creator，现在在ubuntu上开发，做opencv相关的学习，自己也把qmake改成强大的cmake了，结果发现一直找不到c的编译器，很是奇怪（系统由14.04升级到16.04）： No CMAKE_C_COMPILER could be found 终端里面命令： which gcc 也能找到路径。 最终没辙，只得在环境变量中定义才解决。至于为啥会造成找不到gcc路径，目前还不清楚，先记录下这个问题。","tags":[{"name":"日常记录","slug":"日常记录","permalink":"https://koala99.github.io/tags/日常记录/"},{"name":"ubuntu","slug":"ubuntu","permalink":"https://koala99.github.io/tags/ubuntu/"}]},{"title":"opencv的安装和配置","date":"2016-05-17T13:15:30.000Z","path":"2016/05/17/opencv的安装和配置/","text":"opencv是计算机视觉处理必备，自己趁这段时间工作不是很繁忙，也开始学习下。1 预先安装一些软件： sudo apt-get install build-essential cmake libgtk2.0-dev pkg-config python-dev python-numpy libavcodec-dev libavformat-dev libswscale-dev2 去管网下载opencv压缩包 3 解压压缩包到某文件夹（用windows习惯了，直接右键提取到此处。。。） 4 command中cd到该解压缩的文件夹中，然后创建build文件夹 mkdir build 5 进入build目录 cd build 6 编译opencv源码 cmake -D CMAKE_BUILD_TYPE=RELEASE -D CMAKE_INSTALL_PREFIX=/usr/local .. 7 安装 sudo make install 自己环境配置是ubuntu+qt+opencv， opencv直接官网下载，源码编译安装，这部分就不用介绍了，值得注意的是，在qt creator中引用libs库时，需在.pro文件中做如下配置： INCLUDEPATH += /usr/local/include\\ /usr/local/include/opencv\\ /usr/local/include/opencv2LIBS += -L/usr/local/lib -lopencv_core -lopencv_imgcodecs -lopencv_highgui TEMPLATE = appCONFIG += console c++11CONFIG -= app_bundleCONFIG -= qt SOURCES += main.cpp环境配置好了，后面继续学习。","tags":[{"name":"opencv ubuntu","slug":"opencv-ubuntu","permalink":"https://koala99.github.io/tags/opencv-ubuntu/"}]},{"title":"机器学习入门系列_knn","date":"2015-04-11T12:56:00.000Z","path":"2015/04/11/knn算法和应用/","text":"knn也就是K最近邻算法，采用测量不同特征值之间的距离方法进行分类，具体操作流程也就分以下几步： 1:计算已知类别数据集中的点与当前点的距离 2：按照距离递增排序 3：选取与当前距离最小的k个点 4：确认前k个点所在类别的出现频率 5：返回前k个点出现频率最高的类别作为当前点的预测分类 书上第一张也给出了一个简单的knn测试,里面引用了numpy库,源码如下: from numpy import *import operatorfrom os import listdirdef classify0(inX, dataSet, labels, k): # 计算距离 #获取dataSet的长度 dataSetSize = dataSet.shape[0] #生成新的矩阵，减去存在的矩阵 diffMat = tile(inX, (dataSetSize,1)) - dataSet #矩阵元素平方 sqDiffMat = diffMat**2 #axis=1 行相加， axis=0 列相加 sqDistances = sqDiffMat.sum(axis=1) #开方 distances = sqDistances**0.5 #函数是将x中的元素从小到大排列，提取其对应的index(索引) sortedDistIndicies = distances.argsort() print(sortedDistIndicies) #选择距离最小的k个点 classCount={} for i in range(k): print(sortedDistIndicies[i]) voteIlabel = labels[sortedDistIndicies[i]] print(voteIlabel) classCount[voteIlabel] = classCount.get(voteIlabel,0) + 1 print(classCount) #排序 sortedClassCount = sorted(classCount.iteritems(), key=operator.itemgetter(1), reverse=True) print(sortedClassCount) return sortedClassCount[0][0] def createDataSet(): group = array([[1.0,1.1],[1.0,1.0],[0,0],[0,0.1]]) labels = [‘A’,’A’,’B’,’C’] return group, labelsif name == “main“: data = createDataSet() print(classify0([0,0],data[0],data[1],3))","tags":[{"name":"机器学习","slug":"机器学习","permalink":"https://koala99.github.io/tags/机器学习/"}]},{"title":"机器学习入门系列_准备篇","date":"2015-04-10T11:52:53.000Z","path":"2015/04/10/机器学习初学/","text":"现在公司的一个留美回来的博士就是美国那边做机器学习方面的工作，当时感觉还挺有意思的，觉得机器学习也很有前途的，于是还买了一本图解学习的书看了下，奈何里面都是公式的推导，看的懵逼懵逼的。 可能我擅长实践但是缺乏理论，于是乎，趁最近工作不是很繁忙，自己重新捡回来了大学的高数，概率论和线性代数。 首先记录下机器学习的一些数学基本知识。 高数：常见函数求导导数运算法则复合函数求导方向导数与梯度（难点）凸集与凸函数一元函数求极值多元函数求极值（了解）拉格朗日乘子法泰勒公式展开空间解析几何和向量代数 线性代数 线性代数：矩阵的定义，矩阵的转置单位矩阵，三角矩阵，对称矩阵向量内积，相关性正交向量组，标准正交基，正交矩阵特征值分解 概率论事件的关系与运算：条件概率，全概率公式，贝叶斯公式随机变量的期望，方差协方差，相关系数，协方差矩阵概率分布：0-1分布，二项分布，高斯分布极大似然函数估计大数定律，伯努利大数定律，中心极限定理 这次，自己又买了一本machine learning in action的书籍，从它开始一步一步学习。","tags":[{"name":"机器学习","slug":"机器学习","permalink":"https://koala99.github.io/tags/机器学习/"}]},{"title":"NumPy常用的函数库","date":"2015-03-05T02:15:01.000Z","path":"2015/03/05/NumPy常用的函数库/","text":"创建二维数组 array()：array = ones(5)array = [1,1,1,1,1]array = empty(5)使用ones可以创建任意维度和元素个数的数组，其元素均为1。zeros（） 全是0 的矩阵，empty函数的使用方法一样，只是它创建的是数组所有元素均为空，所以它是速度最快的创建数组的方法。set = array([[1., 2, ],[3., 4.],[5., 6.],[7., 9.]]) 求数组的 行数： set.shape[0] 4求数组的列数：set.shape[1] 2求数组的大小 set.shape(4, 2)求数组的类型 set.dtypedtype(‘float64’) numpy.eye(N,M=None, k=0, dtype=) 关注第一个第三个参数就行了 第一个参数：输出方阵（行数=列数）的规模，即行数或列数 第三个参数：默认情况下输出的是对角线全“1”，其余全“0”的方阵，如果k为正整数，则在右上方第k条对角线全“1”其余全“0”，k为负整数则在左下方第k条对角线全“1”其余全“0”。 创建矩阵 identity() tile(1,2)： array([1, 1]) tile((1,2,3),3)： array([1, 2, 3, 1, 2, 3, 1, 2, 3]) b=[1,3,5] tile(b,[2,3])： array([[1, 3, 5, 1, 3, 5, 1, 3, 5], [1, 3, 5, 1, 3, 5, 1, 3, 5]]) c = np.array([[0, 2, 1], [3, 5, 6], [0, 1, 1]]) print c.sum()print c.sum(axis=0)print c.sum(axis=1) 结果分别是：19, [3 8 8], [ 3 14 2] 函数是将x中的元素从小到大排列，提取其对应的index(索引)array.argsort() Out[4]: array([3, 2, 0, 1]) x = np.array([[0, 3], [2, 2]])： array([[0, 3], [2, 2]]) np.argsort(x, axis=0) #按列排序 array([[0, 1], [1, 0]]) np.argsort(x, axis=1) #按行排序 array([[0, 1], [0, 1]])","tags":[{"name":"机器学习","slug":"机器学习","permalink":"https://koala99.github.io/tags/机器学习/"},{"name":"numpy","slug":"numpy","permalink":"https://koala99.github.io/tags/numpy/"}]},{"title":"android架构浅谈","date":"2014-11-13T13:30:20.000Z","path":"2014/11/13/android架构浅谈/","text":"从做安卓开始，心中最熟悉的还是mvc这中架构，上大学那会，自己写最初写java web那会，就是构造java bean，jsp做展现，servlet做控制器，慢慢到后来，随着用到ssh这些框架，分层也越来越细了。写了两年多的安卓，基本还是沿用mvc框架来处理问题。今年开始流行起来mvp这个框架了，这个框架最初还是在微软.net平台上实践，慢慢有人就开始用到安卓上来了。为什么要用mvp？肯定还是android上mvc不够好，首先我们来看这个模型图：明显可以注意到 这三层形成了一个回路，耦合度高。看看android上mvc的实现，View层：定义View或ViewGroup或xml，负责将用户的请求通知Controller，并根据model更新界面；Controller层：我们的activity或者fragment这个根据model更改界面；model：最常见的java bean和网络回传的数据看似划分的很清楚，其实问题就出在activity或fragment上，他们里面也有大量处理ui的代码，页面操作也在这里面，从而造成耦合度过高，一个很简单的例子，我们定义了很多button，每个button的的动作监听需要在activity中，监听后改变ui也在activity中，一旦控件过多，activity就很膨胀。于是我们就开始引出mvp了，他实际上是mvc的改造，看图说话：最大的区别就是model与view完全解绑了，不会打交道了。view就是我们那些xml，activity，presenter处理具体业务model不变。这里可能出问题的就是presenter对activity或fragment的引用，一般采用弱引用来解决这个问题。总结下它们的处理流程:在MVC中，用户的请求首先会到达Controller,有Controller从Model获取数据，选择合适的View,把处理结果呈现到View上；在MVP中，用户的请求首先会到达View,View传递请求到特定的Presenter,Presenter从Model获取数据后，再把处理结果通过接口传递到View。","tags":[]},{"title":"java gc原理","date":"2014-10-13T12:24:30.000Z","path":"2014/10/13/java gc原理/","text":"作为android开发人员，了解java的GC工作原理很有必要。我们开发的app需要不断的优化，这就包括如何优化GC的性能、如何与GC进行有限的交互。 这边就从一个简单的demo展开。在idea 运行中配置如下代码: -server -Xms10m -Xmx10m -XX:+DoEscapeAnalysis -XX:+PrintGc 这边先介绍几个概念： -Xms 10m，表示JVM Heap(堆内存)最小尺寸10MB，最开始只有 -Xms 的参数，表示 初始 memory size(m表示memory，s表示size)，属于初始分配10m，-Xms表示的 初始 内存也有一个 最小 内存的概念（其实常用的做法中初始内存采用的也就是最小内存）。 -Xmx 10m，表示JVM Heap(堆内存)最大允许的尺寸10MB，按需分配。如果 -Xmx 不指定或者指定偏小，也许出现java.lang.OutOfMemory错误，此错误来自JVM不是Throwable的，无法用try…catch捕捉。 DoEscapeAnalysis 逃逸模式，前面+代表启用，-号代表关闭 PrintGc 打印gc信息 测试代码如下： public class Test { /** * 内分配了两个字节的内存空间 */ public static void alloc(){ int[] array = new int[2]; array[0] = 1; } public static void main(String[] args) { long startTime = System.currentTimeMillis(); // 分配 100000000 个 alloc 分配的内存空间 for(int i = 0; i &lt; 100000000; i++){ alloc(); } long endTime = System.currentTimeMillis(); System.out.println(endTime - startTime); } } 可以看到跟踪的gc信息，一连串如下： [GC (Allocation Failure) 2472K-&gt;424K(9728K), 0.0030868 secs] 看起来还不够详细，可以继续配置如下命令 -XX:+PrintGCDetails，运行可以看到如下结果： [GC (Allocation Failure) [PSYoungGen: 2048K-&gt;0K(2560K)] 2488K-&gt;440K(9728K), 0.0003446 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]1832Heap PSYoungGen total 2560K, used 1515K [0x00000007bfd00000, 0x00000007c0000000, 0x00000007c0000000) eden space 2048K, 73% used [0x00000007bfd00000,0x00000007bfe7ad80,0x00000007bff00000) from space 512K, 0% used [0x00000007bff80000,0x00000007bff80000,0x00000007c0000000) to space 512K, 0% used [0x00000007bff00000,0x00000007bff00000,0x00000007bff80000) ParOldGen total 7168K, used 440K [0x00000007bf600000, 0x00000007bfd00000, 0x00000007bfd00000) object space 7168K, 6% used [0x00000007bf600000,0x00000007bf66e050,0x00000007bfd00000) Metaspace used 2991K, capacity 4494K, committed 4864K, reserved 1056768K class space used 327K, capacity 386K, committed 512K, reserved 1048576K 看最后的heap总结，这里就可以看到划分去了几个generation，PSYoungGen ParOldGen Metaspace，Metaspace，在jdk1.8中， Permanent Generation已经取代了Metaspace， young gen中就有我们熟悉的伊甸区 eden space，关于各区的介绍，这里详细的概述下： JVM在程序运行过程当中，会创建大量的对象，这些对象，大部分是短周期的对象，小部分是长周期的对象，对于短周期的对象，需要频繁地进行垃圾回收以保证无用对象尽早被释放掉，对于长周期对象，则不需要频率垃圾回收以确保无谓地垃圾扫描检测。为解决这种矛盾，Sun JVM的内存管理采用分代的策略。 1）年轻代(Young Gen)：年轻代主要存放新创建的对象，内存大小相对会比较小，垃圾回收会比较频繁。年轻代分成1个Eden Space和2个Suvivor Space（命名为A和B）。当对象在堆创建时，将进入年轻代的Eden Space。垃圾回收器进行垃圾回收时，扫描Eden Space和A Suvivor Space，如果对象仍然存活，则复制到B Suvivor Space，如果B Suvivor Space已经满，则复制到Old Gen。同时，在扫描Suvivor Space时，如果对象已经经过了几次的扫描仍然存活，JVM认为其为一个持久化对象，则将其移到Old Gen。扫描完毕后，JVM将Eden Space和A Suvivor Space清空，然后交换A和B的角色（即下次垃圾回收时会扫描Eden Space和BSuvivor Space。这么做主要是为了减少内存碎片的产生。 我们可以看到：Young Gen垃圾回收时，采用将存活对象复制到到空的Suvivor Space的方式来确保尽量不存在内存碎片，采用空间换时间的方式来加速内存中不再被持有的对象尽快能够得到回收。2）年老代(Tenured Gen)：年老代主要存放JVM认为生命周期比较长的对象（经过几次的Young Gen的垃圾回收后仍然存在），内存大小相对会比较大，垃圾回收也相对没有那么频繁（譬如可能几个小时一次）。年老代主要采用压缩的方式来避免内存碎片（将存活对象移动到内存片的一边，也就是内存整理）。当然，有些垃圾回收器（譬如CMS垃圾回收器）出于效率的原因，可能会不进行压缩。3）持久代(Perm Gen)：持久代主要存放类定义、字节码和常量等很少会变更的信息。 了解了这些，其实我们也该清楚一些优化的方法，为什么常量不宜太多，年轻区的内存空间应该大，太小了，操作频繁的数据都会进入年老区，垃圾回收不频繁。 言归正传，继续谈我们的GC，首先讲下我们的垃圾回收算法，古老的引用计数法。它的基本思想很简单，对于一个对象A，只要有任何一个对象引用了A，则A的引用计数器就加1，当引用失效时，引用计数器就减1。只要对象A的引用计数器的值为0，则对象A就不可能再被使用。就可以回收了。它的缺点也很明显，1，每次引用和去引用都需要加减，性能不行；2循环引用问题，可以看下简单代码。 class A{ public B b; }class B{ public A a;}public class Main{ public static void main(String[] args){ A a = new A(); B b = new B(); a.b=b; b.a=a; }} 这种情况下，谁都没法回收。java的垃圾回收使用的基本的算法思想是标记-清除算法： 标记-清除算法是现代垃圾回收算法的思想基础。将垃圾回收分为两个阶段：标记阶段和清除阶段。 一种可行的实现是，在标记阶段，首先通过根节点，标记所有从根节点开始的可达对象（从GC ROOT开始标记引用链——又叫可达性算法）。因此，未被标记的对象就是未被引用的垃圾对象。然后，在清除阶段，清除所有未被标记的对象。这样就不怕循环问题了。 具体效果图如下： 这种算法的缺点就是容易出现内存碎片。利用率不高。要知道，现代的Java虚拟机都是使用的分代回收的设计，比如在标记-清除算法的基础上做了一些优化的——标记-压缩算法，适合用于存活对象较多的场合，如老年代。 和标记-清除算法一样，标记-压缩算法也首先需要从根节点开始，对所有可达对象做一次标记。但之后，它并不简单的清理未标记的对象，而是将所有的存活对象压缩到内存的一端。之后，清理边界外所有的空间。有效解决内存碎片问题。 和标记-清除算法相比，复制算法是一种相对高效的回收方法，但是 不适用于存活对象较多的场合如老年代，使用在新生代， 原理是 将原有的内存空间分为两块，两块空间完全相同，每次只用一块，在垃圾回收时，将正在使用的内存中的存活对象复制到未使用的内存块中，之后，清除正在使用的内存块中的所有对象，交换两个内存的角色，完成垃圾回收。同样也没有内存 碎片产生。 复制算法的缺点是内存的浪费，因为每次只是使用了一般的空间， 而大多数存活对象都在老年代，故复制算法不用在老年代，老年代是Java堆的空间的担保地区。复制算法主要用在新生代。在垃圾回收的时候，大对象直接从新生代进入了老年代存放，大对象一般不使用复制算法，因为一是太大，复制效率低，二是过多的大对象，会使得小对象复制的时候无地方存放。还有被长期引用的对象也放在了老年代。 Java的垃圾回收机制使用的是分代的思想。 依据对象的存活周期进行分类，短命对象归为新生代，长命对象归为老年代。根据不同代的特点，选取合适的收集算法。少量对象存活（新生代，朝生夕死的特性），适合复制算法，大量对象存活（老年代，生命周期很长，甚至和应用程序存放时间一样），适合标记清理或者标记压缩算法。","tags":[{"name":"java","slug":"java","permalink":"https://koala99.github.io/tags/java/"},{"name":"垃圾回收","slug":"垃圾回收","permalink":"https://koala99.github.io/tags/垃圾回收/"}]},{"title":"lbs开发中遇到的问题","date":"2014-09-15T11:09:03.000Z","path":"2014/09/15/lbs开发中遇到的问题/","text":"在开发莫比动力中，遇到了一些问题，这边记录下，莫比动力采用的是百度地图的sdk进行定位服务，根据运动状况，记录运动轨迹。 首先必不可少遇到轨迹漂移的问题，个别轨迹漂移的问题还好解决，有时候就怕遇到长时间轨迹漂移的情况。 当个别位置漂移时，这边主要根据运动状态做了地址栅栏（在规定半径形成的圆中），如果不在此范围内，算作gps漂移，像静止状态下，速度立刻置零，而且不进行更新地图上的经纬度；运动状态时，就需要根据运动速度，首先判断速度，类似那种超大速度，超大距离的点（与速度相关），都需要过滤掉。 长时间漂移这边处理的方法，这边采用的是从第一个异常点开始计算，一定时间内，连续的出现异常点大于20这个边界值，就把这段时间的内统一清空，看做长时间漂移。 在地图上展现轨迹时，如果把记录的点直接描点连线的话，会发现基本都是很突兀的直线连接，这边就需要采用 滑动平均平滑 算法，它的实现很简单，相邻5个点一组，进行计算: 这样绘制的曲线就更加平滑了。","tags":[{"name":"lbs","slug":"lbs","permalink":"https://koala99.github.io/tags/lbs/"},{"name":"优化","slug":"优化","permalink":"https://koala99.github.io/tags/优化/"}]},{"title":"hashmap详解","date":"2014-08-03T13:30:30.000Z","path":"2014/08/03/java hashmap原理/","text":"hashmap在java中，我们一般面试中会经常问到:1.什么时候会使用HashMap？他有什么特点？2.你知道HashMap的工作原理吗？3.你知道get和put的原理吗？equals()和hashCode()的都有什么作用？4.如果HashMap的大小超过了负载因子(load factor)定义的容量，怎么办？ 为什么运行下面代码块： HashMap map = new HashMap(); map.put(“语文”, 1); map.put(“数学”, 2); map.put(“英语”, 3); map.put(“历史”, 4); map.put(“政治”, 5); map.put(“地理”, 6); map.put(“生物”, 7); map.put(“化学”, 8); for(Map.Entry entry : map.entrySet()) { System.out.println(entry.getKey() + “: “ + entry.getValue()); } 结果却并非我们想象的那样： 这篇文章就带你去解决这些问题。HashMap最新代码：点击查看 首先解决上面的问题，为什么排序不一致呢？看看源代码的描述。简单翻译最后一句就是：它不确保顺序。不信，你再添加元素看看运行的结果。hashmap中有两个重要的参数，容量(Capacity)和负载因子(Load factor)，容量就是hashmap的大小，负载因子就是填满的比例。再来看我们常用的put函数，添加元素，它的具体代码如下： 610 public V More …put(K key, V value) {611 return putVal(hash(key), key, value, false, true);612 }inal V More …putVal(int hash, K key, V value, boolean onlyIfAbsent,625 boolean evict) {626 Node[] tab; Node p; int n, i;627 if ((tab = table) == null || (n = tab.length) == 0)628 n = (tab = resize()).length;629 if ((p = tab[i = (n - 1) &amp; hash]) == null)630 tab[i] = newNode(hash, key, value, null);631 else {632 Node e; K k;633 if (p.hash == hash &amp;&amp;634 ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))635 e = p;636 else if (p instanceof TreeNode)637 e = ((TreeNode)p).putTreeVal(this, tab, hash, key, value);638 else {639 for (int binCount = 0; ; ++binCount) {640 if ((e = p.next) == null) {641 p.next = newNode(hash, key, value, null);642 if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st643 treeifyBin(tab, hash);644 break;645 }646 if (e.hash == hash &amp;&amp;647 ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))648 break;649 p = e;650 }651 }652 if (e != null) { // existing mapping for key653 V oldValue = e.value;654 if (!onlyIfAbsent || oldValue == null)655 e.value = value;656 afterNodeAccess(e);657 return oldValue;658 }659 }660 ++modCount;661 if (++size &gt; threshold)662 resize();663 afterNodeInsertion(evict);664 return null;665 } 具体流程，可以总结为：对key的hashCode()做hash，然后再计算index;如果没碰撞直接放到bucket里；如果碰撞了，以链表的形式存在buckets后；如果碰撞导致链表过长(大于等于TREEIFY_THRESHOLD)，就把链表转换成红黑树；如果节点已经存在就替换old value(保证key的唯一性)如果bucket满了(超过load factor*current capacity)，就要resize。再看看我们用的get方法： public V More …get(Object key) {555 Node e;556 return (e = getNode(hash(key), key)) == null ? null : e.value;557 }566 final Node More …getNode(int hash, Object key) {567 Node[] tab; Node first, e; int n; K k;568 if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp;569 (first = tab[(n - 1) &amp; hash]) != null) {570 if (first.hash == hash &amp;&amp; // always check first node571 ((k = first.key) == key || (key != null &amp;&amp; key.equals(k))))572 return first;573 if ((e = first.next) != null) {574 if (first instanceof TreeNode)575 return ((TreeNode)first).getTreeNode(hash, key);576 do {577 if (e.hash == hash &amp;&amp;578 ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))579 return e;580 } while ((e = e.next) != null);581 }582 }583 return null;584 }这代码看起来就简单多了，bucket里的第一个节点，直接命中；如果有冲突，则通过key.equals(k)去查找对应的entry若为树，则在树中通过key.equals(k)查找，O(logn)；若为链表，则在链表中通过key.equals(k)查找，O(n)。超过阀值后，我们需要进行扩容，这时就需要调用resize方法，代码如下： final Node[] More …resize() {677 Node[] oldTab = table;678 int oldCap = (oldTab == null) ? 0 : oldTab.length;679 int oldThr = threshold;680 int newCap, newThr = 0;681 if (oldCap &gt; 0) {682 if (oldCap &gt;= MAXIMUM_CAPACITY) {683 threshold = Integer.MAX_VALUE;684 return oldTab;685 }686 else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp;687 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)688 newThr = oldThr &lt;&lt; 1; // double threshold689 }690 else if (oldThr &gt; 0) // initial capacity was placed in threshold691 newCap = oldThr;692 else { // zero initial threshold signifies using defaults693 newCap = DEFAULT_INITIAL_CAPACITY;694 newThr = (int)(DEFAULT_LOAD_FACTOR DEFAULT_INITIAL_CAPACITY);695 }696 if (newThr == 0) {697 float ft = (float)newCap loadFactor;698 newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ?699 (int)ft : Integer.MAX_VALUE);700 }701 threshold = newThr;702 @SuppressWarnings({“rawtypes”,”unchecked”})703 Node[] newTab = (Node[])new Node[newCap];704 table = newTab;705 if (oldTab != null) {706 for (int j = 0; j &lt; oldCap; ++j) {707 Node e;708 if ((e = oldTab[j]) != null) {709 oldTab[j] = null;710 if (e.next == null)711 newTab[e.hash &amp; (newCap - 1)] = e;712 else if (e instanceof TreeNode)713 ((TreeNode)e).split(this, newTab, j, oldCap);714 else { // preserve order715 Node loHead = null, loTail = null;716 Node hiHead = null, hiTail = null;717 Node next;718 do {719 next = e.next;720 if ((e.hash &amp; oldCap) == 0) {721 if (loTail == null)722 loHead = e;723 else724 loTail.next = e;725 loTail = e;726 }727 else {728 if (hiTail == null)729 hiHead = e;730 else731 hiTail.next = e;732 hiTail = e;733 }734 } while ((e = next) != null);735 if (loTail != null) {736 loTail.next = null;737 newTab[j] = loHead;738 }739 if (hiTail != null) {740 hiTail.next = null;741 newTab[j + oldCap] = hiHead;742 }743 }744 }745 }746 }747 return newTab;748 }在resize的过程，简单的说就是把bucket扩充为2倍，之后重新计算index，把节点再放到新的hashmap中。现在我们就可以回答上面的问题了： 什么时候会使用HashMap？他有什么特点？是基于Map接口的实现，存储键值对时，它可以接收null的键值，是非同步的，HashMap存储着Entry(hash, key, value, next)对象。 你知道HashMap的工作原理吗？通过hash的方法，通过put和get存储和获取对象。存储对象时，我们将K/V传给put方法时，它调用hashCode计算hash从而得到bucket位置，进一步存储，HashMap会根据当前bucket的占用情况自动调整容量(超过Load Facotr则resize为原来的2倍)。获取对象时，我们将K传给get，它调用hashCode计算hash从而得到bucket位置，并进一步调用equals()方法确定键值对。如果发生碰撞的时候，Hashmap通过链表将产生碰撞冲突的元素组织起来，在Java 8中，如果一个bucket中碰撞冲突的元素超过某个限制(默认是8)，则使用红黑树来替换链表，从而提高速度。 你知道get和put的原理吗？equals()和hashCode()的都有什么作用？通过对key的hashCode()进行hashing，并计算下标( n-1 &amp; hash)，从而获得buckets的位置。如果产生碰撞，则利用key.equals()方法去链表或树中去查找对应的节点 如果HashMap的大小超过了负载因子(load factor)定义的容量，怎么办？如果超过了负载因子(默认0.75)，则会重新resize一个原来长度两倍的HashMap，并且重新调用hash方法。","tags":[{"name":"java","slug":"java","permalink":"https://koala99.github.io/tags/java/"},{"name":"hashmap","slug":"hashmap","permalink":"https://koala99.github.io/tags/hashmap/"}]},{"title":"布局标签的简单思考","date":"2013-04-11T12:19:42.000Z","path":"2013/04/11/布局标签的简单思考/","text":"一直在用用一些常用的布局标签，include,merge,viewstub，但是否真的了解其原理呢？ 首先我们用的viewstub实际上就是一个懒加载，为什么这么说呢？来看源码： public final class ViewStub extends View { ...... public View inflate() { final ViewParent viewParent = getParent(); // 1 为什么可以直接获取父视图？ // ViewStub的父视图必须是ViewGroup的子类 if (viewParent != null &amp;&amp; viewParent instanceof ViewGroup) { if (mLayoutResource != 0) { // ViewStub必须设置android:layout属性 final ViewGroup parent = (ViewGroup) viewParent; final LayoutInflater factory; if (mInflater != null) { factory = mInflater; } else { factory = LayoutInflater.from(mContext); } // 2 inflate被加载视图 final View view = factory.inflate(mLayoutResource, parent, false); if (mInflatedId != NO_ID) { view.setId(mInflatedId); } // 从父视图中获取当前ViewStub在父视图中的位置 final int index = parent.indexOfChild(this); // 当前ViewStub也是个View仅仅只是用来占位，所以先把占位的ViewStub视图删除 parent.removeViewInLayout(this); // 3 此处获取的是ViewStub上面设置的参数 final ViewGroup.LayoutParams layoutParams = getLayoutParams(); if (layoutParams != null) { parent.addView(view, index, layoutParams); } else { parent.addView(view, index); } // 目的是在复写的setVisibility方法中使用 // 因为ViewStub.setVisibility操作的是被加载视图并非当前ViewStub视图 mInflatedViewRef = new WeakReference&lt;View&gt;(view); // 调用监听 if (mInflateListener != null) { mInflateListener.onInflate(this, view); } // 返回被加载视图，如果不需要当前可以忽略此返回对象 return view; } else { throw new IllegalArgumentException(&quot;ViewStub must have a valid layoutResource&quot;); } } else { throw new IllegalStateException(&quot;ViewStub must have a non-null ViewGroup viewParent&quot;); } } ...... } 可以发现，它构造时： public ViewStub(Context context, AttributeSet attrs, int defStyleAttr, int defStyleRes) { super(context); final TypedArray a = context.obtainStyledAttributes(attrs, R.styleable.ViewStub, defStyleAttr, defStyleRes); mInflatedId = a.getResourceId(R.styleable.ViewStub_inflatedId, NO_ID); mLayoutResource = a.getResourceId(R.styleable.ViewStub_layout, 0); mID = a.getResourceId(R.styleable.ViewStub_id, NO_ID); a.recycle(); setVisibility(GONE); setWillNotDraw(true); } 首选设置需要加载的view为gone，setWillNotDraw为true，继承View.java，代表就是不绘制该布局，而我们一般的view设置为gone时，默认会加入布局绘制的，viewstub它真正绘制就是在调用了inflate()方法时，viewparent就把它加入进来。merge我们也经常用到，它起的作用也很简单，减少层级，看看主要源码: mLayout = new LinearLayout(this); mLayout.setOrientation(LinearLayout.VERTICAL); LayoutInflater.from(this).inflate(R.layout.merge_tag, mLayout); setContentView(mLayout); 另外我们经常会加一个空格空间，经常的做法就是一个没有文字的textview来做，，这样它会参与视图的绘制，实际上我们可以用Space来做，看他的源码可以发现，它的ondraw方法为空，确实很轻量级。","tags":[]},{"title":"activity的一些生命周期场景","date":"2012-09-11T12:37:35.000Z","path":"2012/09/11/activity的一些生命周期场景/","text":"1，进入Activity onCreate -&gt; onStart -&gt; onResume2，BACK键 onPause -&gt; onStop -&gt; onDestroy3，HOME键 Home键退出：onPause -&gt; onStop Home键回来：onRestart -&gt; onStart -&gt; onResume4，休眠/恢复 休眠：onPause 恢复：onResume5，旋转屏幕 未设置android:configChanges： onPause -&gt; onStop -&gt; onDestory -&gt; onCreate -&gt; onStart -&gt; onResume设置了android:configChanges=”orientation| keyboardHidden”：不会触发生命周期方法.6，来电 来电，显示来电界面：onPause -&gt; onStop 关闭电话界面，重新回到当前Activity：onRestart -&gt; onStart -&gt; onResume 7,其他Activity 进入下一个Activity： A.onPause -&gt; B.onCreate -&gt; B.onStart -&gt;B.onResume -&gt; A.onStop 从其他Activity返回至当前Acitivity： onRestart -&gt; onStart -&gt; onResume 与Activity生命周期结合的应用场景3.1 与广播(Broadcast)结合 在onResume注册广播(registerLinstener)，在onPause注销广播(unregisterLinstener)。 例如： 做”摇一摇”功能（传感器）、监听网络变化，就可以在onResume中注册监听，在onPause里注销掉，已节省资源提高效率。 3.2与服务(Service)结合 在onStart绑定服务(bindService)，在onStop中取消绑定(unbindService)。 例如： 需要通过Service定时更新UI上的数据，而Activity的可见周期在onStart与onStop之间，那么就可以再onStart时启动服务，在onStop时停止服务。为了节约系统资源，除了提高用户体验以外，开发人员应尽可能的优化程序。 3.3 与Cursor结合 使用managedQuery让Activity帮你管理Cursor的生命周期，不用自己去close。 3.4 释放资源 可以在onDestory中释放一些资源。比如可以在onDestory时调用MediaPlayer的release。","tags":[]}]