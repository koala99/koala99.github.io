[{"title":"ios 开发小结","date":"2016-09-20T13:54:34.000Z","path":"2016/09/20/ios-开发小结/","text":"很早就接触swift了，之前虽然写过一些简单的demo，但还没系统性完成一个商业app。之前开发完了公司的安卓版产品，没有ios，自己就承担开发ios的版本，算下来，时间比安卓开发稍微长一点，考虑到swift 3版本升级，造成一些库的兼容处理，总体时间上跟安卓开发时间差不多。这里就介绍一些自己用到的一些库。首先是布局方面，ios开发的布局，自己真的很不喜欢，虽然提供了storyboard这样的可视化拖拉，这边自己都是做autolayout,使用的库是Snapkit,自己通过纯代码来实现布局。虽然代码量大，但是写起来比较熟。网络请求之前用原生的来写，做json解析，真的挺麻烦的，后来采用了SwiftHTTP,使用简单。返回数据这边都做了序列化操作，ios中这边采用了ObjectMapper，它来做实体类的序列化，挺方便的。考虑到我们安卓中常常用到的事务总栈eventbus，swift方面也有对应的实现，基于notification来做的封装。 SwiftEventBus 。使用方法也与eventbus类似。一些图像的异步加载，离线缓存，我这边采用的是功能强大的 HanekeSwift ,它的作用远远不止这些。总体而言，因为app上没有涉及太多的复杂功能点，开发起来很顺利，ios的开发架构也跟安卓一致，最大的变数就是swift这本语言，2.0到3.0变化还有有些大的，当然，coder必须适应这些变化，不断学习。","tags":[{"name":"ios","slug":"ios","permalink":"https://koala99.github.io/tags/ios/"},{"name":"swift","slug":"swift","permalink":"https://koala99.github.io/tags/swift/"}]},{"title":"swift 3.0之后的一些变化","date":"2016-09-11T13:47:32.000Z","path":"2016/09/11/swift-3-0之后的一些变化/","text":"由于之前项目都是swift2写的，现在都得做升级，更新到swift3，这边就做下记录。 CGPointMake -> CGPoint let point = CGPoint(x: 0,y :0) // x和y的值可以是CGFloat, Double, Int CGSizeMake -> CGSize let size = CGSize(width: 100, height: 100) // width和height的值可以是CGFloat, Double, Int CGRectMake -> CGRect 用CGPoint和CGSize来构建 let rect = CGRect(origin: CGPoint(x: 0,y :0), size: CGSize(width: 100, height: 100)) 用CGFloat，Double和Int值构建 let rect = CGRect(x: 0, y: 0, width: 100, height: 100) // 参数类型可以为CGFloat, Double, Int CGRectZero->CGRect.zero & CGPointZero -> CGPoint.zero let size = CGSize.zero // width = 0, height = 0 let point = CGPoint.zero // x = 0, y = 0，等同于CGPointZero let rect = CGRect.zero // 等同与 CGRectZero","tags":[{"name":"ios,swift","slug":"ios-swift","permalink":"https://koala99.github.io/tags/ios-swift/"}]},{"title":"java gc原理","date":"2014-10-13T12:24:30.000Z","path":"2014/10/13/java gc原理/","text":"作为android开发人员，了解java的GC工作原理很有必要。我们开发的app需要不断的优化，这就包括如何优化GC的性能、如何与GC进行有限的交互。 这边就从一个简单的demo展开。在idea 运行中配置如下代码: -server -Xms10m -Xmx10m -XX:+DoEscapeAnalysis -XX:+PrintGc 这边先介绍几个概念： -Xms 10m，表示JVM Heap(堆内存)最小尺寸10MB，最开始只有 -Xms 的参数，表示 初始 memory size(m表示memory，s表示size)，属于初始分配10m，-Xms表示的 初始 内存也有一个 最小 内存的概念（其实常用的做法中初始内存采用的也就是最小内存）。 -Xmx 10m，表示JVM Heap(堆内存)最大允许的尺寸10MB，按需分配。如果 -Xmx 不指定或者指定偏小，也许出现java.lang.OutOfMemory错误，此错误来自JVM不是Throwable的，无法用try…catch捕捉。 DoEscapeAnalysis 逃逸模式，前面+代表启用，-号代表关闭 PrintGc 打印gc信息 测试代码如下： public class Test { /** * 内分配了两个字节的内存空间 */ public static void alloc(){ int[] array = new int[2]; array[0] = 1; } public static void main(String[] args) { long startTime = System.currentTimeMillis(); // 分配 100000000 个 alloc 分配的内存空间 for(int i = 0; i &lt; 100000000; i++){ alloc(); } long endTime = System.currentTimeMillis(); System.out.println(endTime - startTime); } } 可以看到跟踪的gc信息，一连串如下： [GC (Allocation Failure) 2472K-&gt;424K(9728K), 0.0030868 secs] 看起来还不够详细，可以继续配置如下命令 -XX:+PrintGCDetails，运行可以看到如下结果： [GC (Allocation Failure) [PSYoungGen: 2048K-&gt;0K(2560K)] 2488K-&gt;440K(9728K), 0.0003446 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]1832Heap PSYoungGen total 2560K, used 1515K [0x00000007bfd00000, 0x00000007c0000000, 0x00000007c0000000) eden space 2048K, 73% used [0x00000007bfd00000,0x00000007bfe7ad80,0x00000007bff00000) from space 512K, 0% used [0x00000007bff80000,0x00000007bff80000,0x00000007c0000000) to space 512K, 0% used [0x00000007bff00000,0x00000007bff00000,0x00000007bff80000) ParOldGen total 7168K, used 440K [0x00000007bf600000, 0x00000007bfd00000, 0x00000007bfd00000) object space 7168K, 6% used [0x00000007bf600000,0x00000007bf66e050,0x00000007bfd00000) Metaspace used 2991K, capacity 4494K, committed 4864K, reserved 1056768K class space used 327K, capacity 386K, committed 512K, reserved 1048576K 看最后的heap总结，这里就可以看到划分去了几个generation，PSYoungGen ParOldGen Metaspace，Metaspace，在jdk1.8中， Permanent Generation已经取代了Metaspace， young gen中就有我们熟悉的伊甸区 eden space，关于各区的介绍，这里详细的概述下： JVM在程序运行过程当中，会创建大量的对象，这些对象，大部分是短周期的对象，小部分是长周期的对象，对于短周期的对象，需要频繁地进行垃圾回收以保证无用对象尽早被释放掉，对于长周期对象，则不需要频率垃圾回收以确保无谓地垃圾扫描检测。为解决这种矛盾，Sun JVM的内存管理采用分代的策略。 1）年轻代(Young Gen)：年轻代主要存放新创建的对象，内存大小相对会比较小，垃圾回收会比较频繁。年轻代分成1个Eden Space和2个Suvivor Space（命名为A和B）。当对象在堆创建时，将进入年轻代的Eden Space。垃圾回收器进行垃圾回收时，扫描Eden Space和A Suvivor Space，如果对象仍然存活，则复制到B Suvivor Space，如果B Suvivor Space已经满，则复制到Old Gen。同时，在扫描Suvivor Space时，如果对象已经经过了几次的扫描仍然存活，JVM认为其为一个持久化对象，则将其移到Old Gen。扫描完毕后，JVM将Eden Space和A Suvivor Space清空，然后交换A和B的角色（即下次垃圾回收时会扫描Eden Space和BSuvivor Space。这么做主要是为了减少内存碎片的产生。 我们可以看到：Young Gen垃圾回收时，采用将存活对象复制到到空的Suvivor Space的方式来确保尽量不存在内存碎片，采用空间换时间的方式来加速内存中不再被持有的对象尽快能够得到回收。2）年老代(Tenured Gen)：年老代主要存放JVM认为生命周期比较长的对象（经过几次的Young Gen的垃圾回收后仍然存在），内存大小相对会比较大，垃圾回收也相对没有那么频繁（譬如可能几个小时一次）。年老代主要采用压缩的方式来避免内存碎片（将存活对象移动到内存片的一边，也就是内存整理）。当然，有些垃圾回收器（譬如CMS垃圾回收器）出于效率的原因，可能会不进行压缩。3）持久代(Perm Gen)：持久代主要存放类定义、字节码和常量等很少会变更的信息。 了解了这些，其实我们也该清楚一些优化的方法，为什么常量不宜太多，年轻区的内存空间应该大，太小了，操作频繁的数据都会进入年老区，垃圾回收不频繁。 言归正传，继续谈我们的GC，首先讲下我们的垃圾回收算法，古老的引用计数法。它的基本思想很简单，对于一个对象A，只要有任何一个对象引用了A，则A的引用计数器就加1，当引用失效时，引用计数器就减1。只要对象A的引用计数器的值为0，则对象A就不可能再被使用。就可以回收了。它的缺点也很明显，1，每次引用和去引用都需要加减，性能不行；2循环引用问题，可以看下简单代码。 class A{ public B b; }class B{ public A a;}public class Main{ public static void main(String[] args){ A a = new A(); B b = new B(); a.b=b; b.a=a; }} 这种情况下，谁都没法回收。java的垃圾回收使用的基本的算法思想是标记-清除算法： 标记-清除算法是现代垃圾回收算法的思想基础。将垃圾回收分为两个阶段：标记阶段和清除阶段。 一种可行的实现是，在标记阶段，首先通过根节点，标记所有从根节点开始的可达对象（从GC ROOT开始标记引用链——又叫可达性算法）。因此，未被标记的对象就是未被引用的垃圾对象。然后，在清除阶段，清除所有未被标记的对象。这样就不怕循环问题了。 具体效果图如下： 这种算法的缺点就是容易出现内存碎片。利用率不高。要知道，现代的Java虚拟机都是使用的分代回收的设计，比如在标记-清除算法的基础上做了一些优化的——标记-压缩算法，适合用于存活对象较多的场合，如老年代。 和标记-清除算法一样，标记-压缩算法也首先需要从根节点开始，对所有可达对象做一次标记。但之后，它并不简单的清理未标记的对象，而是将所有的存活对象压缩到内存的一端。之后，清理边界外所有的空间。有效解决内存碎片问题。 和标记-清除算法相比，复制算法是一种相对高效的回收方法，但是 不适用于存活对象较多的场合如老年代，使用在新生代， 原理是 将原有的内存空间分为两块，两块空间完全相同，每次只用一块，在垃圾回收时，将正在使用的内存中的存活对象复制到未使用的内存块中，之后，清除正在使用的内存块中的所有对象，交换两个内存的角色，完成垃圾回收。同样也没有内存 碎片产生。 复制算法的缺点是内存的浪费，因为每次只是使用了一般的空间， 而大多数存活对象都在老年代，故复制算法不用在老年代，老年代是Java堆的空间的担保地区。复制算法主要用在新生代。在垃圾回收的时候，大对象直接从新生代进入了老年代存放，大对象一般不使用复制算法，因为一是太大，复制效率低，二是过多的大对象，会使得小对象复制的时候无地方存放。还有被长期引用的对象也放在了老年代。 Java的垃圾回收机制使用的是分代的思想。 依据对象的存活周期进行分类，短命对象归为新生代，长命对象归为老年代。根据不同代的特点，选取合适的收集算法。少量对象存活（新生代，朝生夕死的特性），适合复制算法，大量对象存活（老年代，生命周期很长，甚至和应用程序存放时间一样），适合标记清理或者标记压缩算法。","tags":[{"name":"java","slug":"java","permalink":"https://koala99.github.io/tags/java/"},{"name":"垃圾回收","slug":"垃圾回收","permalink":"https://koala99.github.io/tags/垃圾回收/"}]},{"title":"lbs开发中遇到的问题","date":"2014-09-15T11:09:03.000Z","path":"2014/09/15/lbs开发中遇到的问题/","text":"在开发莫比动力中，遇到了一些问题，这边记录下，莫比动力采用的是百度地图的sdk进行定位服务，根据运动状况，记录运动轨迹。 首先必不可少遇到轨迹漂移的问题，个别轨迹漂移的问题还好解决，有时候就怕遇到长时间轨迹漂移的情况。 当个别位置漂移时，这边主要根据运动状态做了地址栅栏（在规定半径形成的圆中），如果不在此范围内，算作gps漂移，像静止状态下，速度立刻置零，而且不进行更新地图上的经纬度；运动状态时，就需要根据运动速度，首先判断速度，类似那种超大速度，超大距离的点（与速度相关），都需要过滤掉。 长时间漂移这边处理的方法，这边采用的是从第一个异常点开始计算，一定时间内，连续的出现异常点大于20这个边界值，就把这段时间的内统一清空，看做长时间漂移。 在地图上展现轨迹时，如果把记录的点直接描点连线的话，会发现基本都是很突兀的直线连接，这边就需要采用 滑动平均平滑 算法，它的实现很简单，相邻5个点一组，进行计算: 这样绘制的曲线就更加平滑了。","tags":[{"name":"lbs","slug":"lbs","permalink":"https://koala99.github.io/tags/lbs/"},{"name":"优化","slug":"优化","permalink":"https://koala99.github.io/tags/优化/"}]},{"title":"hashmap详解","date":"2014-08-03T13:30:30.000Z","path":"2014/08/03/java hashmap原理/","text":"hashmap在java中，我们一般面试中会经常问到:1.什么时候会使用HashMap？他有什么特点？2.你知道HashMap的工作原理吗？3.你知道get和put的原理吗？equals()和hashCode()的都有什么作用？4.如果HashMap的大小超过了负载因子(load factor)定义的容量，怎么办？ 为什么运行下面代码块： HashMap map = new HashMap(); map.put(“语文”, 1); map.put(“数学”, 2); map.put(“英语”, 3); map.put(“历史”, 4); map.put(“政治”, 5); map.put(“地理”, 6); map.put(“生物”, 7); map.put(“化学”, 8); for(Map.Entry entry : map.entrySet()) { System.out.println(entry.getKey() + “: “ + entry.getValue()); } 结果却并非我们想象的那样： 这篇文章就带你去解决这些问题。HashMap最新代码：点击查看 首先解决上面的问题，为什么排序不一致呢？看看源代码的描述。简单翻译最后一句就是：它不确保顺序。不信，你再添加元素看看运行的结果。hashmap中有两个重要的参数，容量(Capacity)和负载因子(Load factor)，容量就是hashmap的大小，负载因子就是填满的比例。再来看我们常用的put函数，添加元素，它的具体代码如下： 610 public V More …put(K key, V value) {611 return putVal(hash(key), key, value, false, true);612 }inal V More …putVal(int hash, K key, V value, boolean onlyIfAbsent,625 boolean evict) {626 Node[] tab; Node p; int n, i;627 if ((tab = table) == null || (n = tab.length) == 0)628 n = (tab = resize()).length;629 if ((p = tab[i = (n - 1) &amp; hash]) == null)630 tab[i] = newNode(hash, key, value, null);631 else {632 Node e; K k;633 if (p.hash == hash &amp;&amp;634 ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))635 e = p;636 else if (p instanceof TreeNode)637 e = ((TreeNode)p).putTreeVal(this, tab, hash, key, value);638 else {639 for (int binCount = 0; ; ++binCount) {640 if ((e = p.next) == null) {641 p.next = newNode(hash, key, value, null);642 if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st643 treeifyBin(tab, hash);644 break;645 }646 if (e.hash == hash &amp;&amp;647 ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))648 break;649 p = e;650 }651 }652 if (e != null) { // existing mapping for key653 V oldValue = e.value;654 if (!onlyIfAbsent || oldValue == null)655 e.value = value;656 afterNodeAccess(e);657 return oldValue;658 }659 }660 ++modCount;661 if (++size &gt; threshold)662 resize();663 afterNodeInsertion(evict);664 return null;665 } 具体流程，可以总结为：对key的hashCode()做hash，然后再计算index;如果没碰撞直接放到bucket里；如果碰撞了，以链表的形式存在buckets后；如果碰撞导致链表过长(大于等于TREEIFY_THRESHOLD)，就把链表转换成红黑树；如果节点已经存在就替换old value(保证key的唯一性)如果bucket满了(超过load factor*current capacity)，就要resize。再看看我们用的get方法： public V More …get(Object key) {555 Node e;556 return (e = getNode(hash(key), key)) == null ? null : e.value;557 }566 final Node More …getNode(int hash, Object key) {567 Node[] tab; Node first, e; int n; K k;568 if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp;569 (first = tab[(n - 1) &amp; hash]) != null) {570 if (first.hash == hash &amp;&amp; // always check first node571 ((k = first.key) == key || (key != null &amp;&amp; key.equals(k))))572 return first;573 if ((e = first.next) != null) {574 if (first instanceof TreeNode)575 return ((TreeNode)first).getTreeNode(hash, key);576 do {577 if (e.hash == hash &amp;&amp;578 ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))579 return e;580 } while ((e = e.next) != null);581 }582 }583 return null;584 }这代码看起来就简单多了，bucket里的第一个节点，直接命中；如果有冲突，则通过key.equals(k)去查找对应的entry若为树，则在树中通过key.equals(k)查找，O(logn)；若为链表，则在链表中通过key.equals(k)查找，O(n)。超过阀值后，我们需要进行扩容，这时就需要调用resize方法，代码如下： final Node[] More …resize() {677 Node[] oldTab = table;678 int oldCap = (oldTab == null) ? 0 : oldTab.length;679 int oldThr = threshold;680 int newCap, newThr = 0;681 if (oldCap &gt; 0) {682 if (oldCap &gt;= MAXIMUM_CAPACITY) {683 threshold = Integer.MAX_VALUE;684 return oldTab;685 }686 else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp;687 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)688 newThr = oldThr &lt;&lt; 1; // double threshold689 }690 else if (oldThr &gt; 0) // initial capacity was placed in threshold691 newCap = oldThr;692 else { // zero initial threshold signifies using defaults693 newCap = DEFAULT_INITIAL_CAPACITY;694 newThr = (int)(DEFAULT_LOAD_FACTOR DEFAULT_INITIAL_CAPACITY);695 }696 if (newThr == 0) {697 float ft = (float)newCap loadFactor;698 newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ?699 (int)ft : Integer.MAX_VALUE);700 }701 threshold = newThr;702 @SuppressWarnings({“rawtypes”,”unchecked”})703 Node[] newTab = (Node[])new Node[newCap];704 table = newTab;705 if (oldTab != null) {706 for (int j = 0; j &lt; oldCap; ++j) {707 Node e;708 if ((e = oldTab[j]) != null) {709 oldTab[j] = null;710 if (e.next == null)711 newTab[e.hash &amp; (newCap - 1)] = e;712 else if (e instanceof TreeNode)713 ((TreeNode)e).split(this, newTab, j, oldCap);714 else { // preserve order715 Node loHead = null, loTail = null;716 Node hiHead = null, hiTail = null;717 Node next;718 do {719 next = e.next;720 if ((e.hash &amp; oldCap) == 0) {721 if (loTail == null)722 loHead = e;723 else724 loTail.next = e;725 loTail = e;726 }727 else {728 if (hiTail == null)729 hiHead = e;730 else731 hiTail.next = e;732 hiTail = e;733 }734 } while ((e = next) != null);735 if (loTail != null) {736 loTail.next = null;737 newTab[j] = loHead;738 }739 if (hiTail != null) {740 hiTail.next = null;741 newTab[j + oldCap] = hiHead;742 }743 }744 }745 }746 }747 return newTab;748 }在resize的过程，简单的说就是把bucket扩充为2倍，之后重新计算index，把节点再放到新的hashmap中。现在我们就可以回答上面的问题了： 什么时候会使用HashMap？他有什么特点？是基于Map接口的实现，存储键值对时，它可以接收null的键值，是非同步的，HashMap存储着Entry(hash, key, value, next)对象。 你知道HashMap的工作原理吗？通过hash的方法，通过put和get存储和获取对象。存储对象时，我们将K/V传给put方法时，它调用hashCode计算hash从而得到bucket位置，进一步存储，HashMap会根据当前bucket的占用情况自动调整容量(超过Load Facotr则resize为原来的2倍)。获取对象时，我们将K传给get，它调用hashCode计算hash从而得到bucket位置，并进一步调用equals()方法确定键值对。如果发生碰撞的时候，Hashmap通过链表将产生碰撞冲突的元素组织起来，在Java 8中，如果一个bucket中碰撞冲突的元素超过某个限制(默认是8)，则使用红黑树来替换链表，从而提高速度。 你知道get和put的原理吗？equals()和hashCode()的都有什么作用？通过对key的hashCode()进行hashing，并计算下标( n-1 &amp; hash)，从而获得buckets的位置。如果产生碰撞，则利用key.equals()方法去链表或树中去查找对应的节点 如果HashMap的大小超过了负载因子(load factor)定义的容量，怎么办？如果超过了负载因子(默认0.75)，则会重新resize一个原来长度两倍的HashMap，并且重新调用hash方法。","tags":[{"name":"java","slug":"java","permalink":"https://koala99.github.io/tags/java/"},{"name":"hashmap","slug":"hashmap","permalink":"https://koala99.github.io/tags/hashmap/"}]},{"title":"布局标签的简单思考","date":"2013-04-11T12:19:42.000Z","path":"2013/04/11/布局标签的简单思考/","text":"一直在用用一些常用的布局标签，include,merge,viewstub，但是否真的了解其原理呢？ 首先我们用的viewstub实际上就是一个懒加载，为什么这么说呢？来看源码： public final class ViewStub extends View { ...... public View inflate() { final ViewParent viewParent = getParent(); // 1 为什么可以直接获取父视图？ // ViewStub的父视图必须是ViewGroup的子类 if (viewParent != null &amp;&amp; viewParent instanceof ViewGroup) { if (mLayoutResource != 0) { // ViewStub必须设置android:layout属性 final ViewGroup parent = (ViewGroup) viewParent; final LayoutInflater factory; if (mInflater != null) { factory = mInflater; } else { factory = LayoutInflater.from(mContext); } // 2 inflate被加载视图 final View view = factory.inflate(mLayoutResource, parent, false); if (mInflatedId != NO_ID) { view.setId(mInflatedId); } // 从父视图中获取当前ViewStub在父视图中的位置 final int index = parent.indexOfChild(this); // 当前ViewStub也是个View仅仅只是用来占位，所以先把占位的ViewStub视图删除 parent.removeViewInLayout(this); // 3 此处获取的是ViewStub上面设置的参数 final ViewGroup.LayoutParams layoutParams = getLayoutParams(); if (layoutParams != null) { parent.addView(view, index, layoutParams); } else { parent.addView(view, index); } // 目的是在复写的setVisibility方法中使用 // 因为ViewStub.setVisibility操作的是被加载视图并非当前ViewStub视图 mInflatedViewRef = new WeakReference&lt;View&gt;(view); // 调用监听 if (mInflateListener != null) { mInflateListener.onInflate(this, view); } // 返回被加载视图，如果不需要当前可以忽略此返回对象 return view; } else { throw new IllegalArgumentException(&quot;ViewStub must have a valid layoutResource&quot;); } } else { throw new IllegalStateException(&quot;ViewStub must have a non-null ViewGroup viewParent&quot;); } } ...... } 可以发现，它构造时： public ViewStub(Context context, AttributeSet attrs, int defStyleAttr, int defStyleRes) { super(context); final TypedArray a = context.obtainStyledAttributes(attrs, R.styleable.ViewStub, defStyleAttr, defStyleRes); mInflatedId = a.getResourceId(R.styleable.ViewStub_inflatedId, NO_ID); mLayoutResource = a.getResourceId(R.styleable.ViewStub_layout, 0); mID = a.getResourceId(R.styleable.ViewStub_id, NO_ID); a.recycle(); setVisibility(GONE); setWillNotDraw(true); } 首选设置需要加载的view为gone，setWillNotDraw为true，继承View.java，代表就是不绘制该布局，而我们一般的view设置为gone时，默认会加入布局绘制的，viewstub它真正绘制就是在调用了inflate()方法时，viewparent就把它加入进来。merge我们也经常用到，它起的作用也很简单，减少层级，看看主要源码: mLayout = new LinearLayout(this); mLayout.setOrientation(LinearLayout.VERTICAL); LayoutInflater.from(this).inflate(R.layout.merge_tag, mLayout); setContentView(mLayout); 另外我们经常会加一个空格空间，经常的做法就是一个没有文字的textview来做，，这样它会参与视图的绘制，实际上我们可以用Space来做，看他的源码可以发现，它的ondraw方法为空，确实很轻量级。","tags":[]},{"title":"activity的一些生命周期场景","date":"2012-09-11T12:37:35.000Z","path":"2012/09/11/activity的一些生命周期场景/","text":"1，进入Activity onCreate -&gt; onStart -&gt; onResume2，BACK键 onPause -&gt; onStop -&gt; onDestroy3，HOME键 Home键退出：onPause -&gt; onStop Home键回来：onRestart -&gt; onStart -&gt; onResume4，休眠/恢复 休眠：onPause 恢复：onResume5，旋转屏幕 未设置android:configChanges： onPause -&gt; onStop -&gt; onDestory -&gt; onCreate -&gt; onStart -&gt; onResume设置了android:configChanges=”orientation| keyboardHidden”：不会触发生命周期方法.6，来电 来电，显示来电界面：onPause -&gt; onStop 关闭电话界面，重新回到当前Activity：onRestart -&gt; onStart -&gt; onResume 7,其他Activity 进入下一个Activity： A.onPause -&gt; B.onCreate -&gt; B.onStart -&gt;B.onResume -&gt; A.onStop 从其他Activity返回至当前Acitivity： onRestart -&gt; onStart -&gt; onResume 与Activity生命周期结合的应用场景3.1 与广播(Broadcast)结合 在onResume注册广播(registerLinstener)，在onPause注销广播(unregisterLinstener)。 例如： 做”摇一摇”功能（传感器）、监听网络变化，就可以在onResume中注册监听，在onPause里注销掉，已节省资源提高效率。 3.2与服务(Service)结合 在onStart绑定服务(bindService)，在onStop中取消绑定(unbindService)。 例如： 需要通过Service定时更新UI上的数据，而Activity的可见周期在onStart与onStop之间，那么就可以再onStart时启动服务，在onStop时停止服务。为了节约系统资源，除了提高用户体验以外，开发人员应尽可能的优化程序。 3.3 与Cursor结合 使用managedQuery让Activity帮你管理Cursor的生命周期，不用自己去close。 3.4 释放资源 可以在onDestory中释放一些资源。比如可以在onDestory时调用MediaPlayer的release。","tags":[]}]