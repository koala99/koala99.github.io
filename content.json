[{"title":"Fresco","date":"2018-10-16T12:38:01.000Z","path":"2018/10/16/Fresco/","text":"Fresco源码解析： mvc架构：View 对应DraweeView类（实际上是DraweeHolder），其负责展示数据，显示图片。Model对应DraweeHierarchy类，其负责持有数据，用一个层级组织和维护最终绘制和显示的图片。对应DraweeController类，其负责控制数据的逻辑。 内存管理机制，利用了Android 5.0以下版本不会GC回收的Ashem区域，极大的减小了OOM发生的概率，提高了内存利用率。 主要包含3级缓存，按照优先级逐级命中并返回。 1）找Bitmap cache中是否有图片，有则加载，否则接着找； 2）再看Encoded Memory中是否有图片，有则decode，transform 后加载图片，并将图片存储进Bitmap Cache,找不到则接着往下找; 3)下一步看Disk Cache(官网有对这个命名的解释,看完大家都明白了：Yes, we know phones don’t have disks, but it’s too tedious to keep saying local storage cache)，有则decode，transform 后加载图片， 并将图片存储进Bitmap Cache,Encoded Memory中，找不到则接着往下找; 4）最后就是终极network cache寻找，有则decode，transform 后加载图片，并将图片存储进Bitmap Cache ,Encoded Memory, Disk Cache，当然如果没有就直接加载失败了。 这里面涉及到一个知识点：bitmap复用内存块： 对于bitmap而言, getAllocationByteCount（） 是指被复用的内存大小在 android3.0到8.0之前bitmap在内存中的java在8.0以后bitmap在内存中的native中 所以我们要手动释放bitmap这里复用池采用的是弱引用 被gc扫过一次后放入引用队列用 引用队列开启线程进行处理bitmap 将bitmap释放","tags":[]},{"title":"ffmpeg使用中的记录","date":"2017-09-30T06:27:00.000Z","path":"2017/09/30/ffmpeg使用中的记录/","text":"首先是一点简单音视频基本常识： （音频编码率（KBit为单位）/8 + 视频编码率（KBit为单位）/8）× 影片总长度（秒为单位）= 文件大小（MB为单位） 对于音频 首先一张标准音乐CD光盘容量是746.93MB。注意大B是字节，小b是位。一字节（B）等于8位（b）。CD音频是以采样率为44.1KHZ，采样位数为16位，左右双声道（立体声）进行采样的。而一张标准CD光盘的时长是74分钟那么容量计算公式为：(44100162)/8(7460)=783216000字节 转为MB为 783216000/1024/1024=746.93MB(兆字节)对于视频：帧率：影响画面流畅度，与画面流畅度成正比：帧率越大，画面越流畅；帧率越小，画面越有跳动感。如果码率为变量，则帧率也会影响体积，帧率越高，每秒钟经过的画面越多，需要的码率也越高，体积也越大。帧率就是在1秒钟时间里传输的图片的帧数，也可以理解为图形处理器每秒钟能够刷新几次。 分辨率：影响图像大小，与图像大小成正比：分辨率越高，图像越大；分辨率越低，图像越小。 清晰度 在码率一定的情况下，分辨率与清晰度成反比关系：分辨率越高，图像越不清晰，分辨率越低，图像越清晰。 在分辨率一定的情况下，码率与清晰度成正比关系，码率越高，图像越清晰；码率越低，图像越不清晰。 新版本的ffmepg中，音视频的解码，编码都共用同一套了，一个很简单的例子: avcodec_send_packet(pCodecCtx, packet); ret = avcodec_receive_frame(pCodecCtx, pFrame);解码时，先接受到packet，再来获取frame。 avcodec_send_frame avcodec_receive_packet 这两个就是配套来进行编码。 这边有自己以前写的ffmepg的一些应用，比如结合qt做一个播放器，https://github.com/koala99/FFmpegTest/tree/master 还有自己在使用提供的ffplay工具来测试mp4解码分离的yuv 和 pcm时，sample_fmt 对应出来的是 fltp这个格式，所以播放的命令应该就是: ffplay -ar 48000 -channel_layout 4 -channels 1 -f f32le -i audio.pcm 说实话，ffmpeg的门槛算是稍微高的，关键资料少，网上大多简单的都是命令来解决问题。所以，不得不耗费经历，自己来解决问题。","tags":[{"name":"音视频","slug":"音视频","permalink":"https://koala99.github.io/tags/音视频/"}]},{"title":"mac下 clion配置qt的开发环境","date":"2017-09-26T12:57:40.000Z","path":"2017/09/26/mac下-clion配置qt的开发环境/","text":"之前玩qt，都是用自带的 qtCreator 这个编辑器，然后编译项目都是内置的qmake。这段时间，正好在做ffmpeg移植到android去，发现网上有不少关于qt+ffmpeg+opencv的结合，所以自己也把IDE改为了 clion。当然，改过来问题多多，首先项目编译器都是cmake了，然后引入各种库，这里简单做下配置，ffmpeg和qt这边都是通过 homebrew来直接安装的，对应的include路径都在： /usr/local/Cellar/ffmpeg/3.4.1/include/ /usr/local/Cellar/sdl2/2.0.7/include /usr/local/opt/qt/includelib都在： usr/local/Cellar/ffmpeg/3.4.1/lib/ , /usr/local/Cellar/sdl2/2.0.7/lib , /usr/local/opt/qt/lib 遇到的问题主要就是在编写cmakelists里面的配置， 这边贴下自己的代码： cmake_minimum_required(VERSION 3.9)project(QtFFmpeg)set(CMAKE_CXX_FLAGS “${CMAKE_CXX_FLAGS} -std=c++11”)include_directories(/usr/local/Cellar/ffmpeg/3.4.1/include/ ,/usr/local/Cellar/sdl2/2.0.7/include , /usr/local/opt/qt/include)link_directories(/usr/local/Cellar/ffmpeg/3.4.1/lib/ , /usr/local/Cellar/sdl2/2.0.7/lib , /usr/local/opt/qt/lib)set(CMAKE_CXX_STANDARD 11)set(CMAKE_PREFIX_PATH “/usr/local/Cellar/qt/5.10.0”) find_package(Qt5Core REQUIRED)find_package(Qt5Widgets REQUIRED) set(CMAKE_INCLUDE_CURRENT_DIR ON)set(CMAKE_AUTOMOC ON) set(CMAKE_AUTOUIC ON) # .ui filesset(CMAKE_AUTORCC ON)qt5_wrap_ui(ui_FILES mainwindow.ui)set(SOURCE_FILES main.cpp mainwindow.cpp mainwindow.h ${ui_FILES})add_executable(QtFFmpeg main.cpp)target_link_libraries( QtFFmpeg avcodec avdevice avfilter avformat avresample avutil postproc swresample swscale SDL2 Qt5::Widgets Qt5::Core Qt5::Gui 其中set(CMAKEPREFIXPATH “/usr/local/Cellar/qt/5.10.0”)， 这个是设置本地编译的cmake，必须是对应的qt里面的如果我们用到了ui文件，必须使用 qt5wrapui这边先简单记录下，等后续工程完了，打算传到github上去","tags":[{"name":"qt","slug":"qt","permalink":"https://koala99.github.io/tags/qt/"},{"name":"clion","slug":"clion","permalink":"https://koala99.github.io/tags/clion/"},{"name":"cmake","slug":"cmake","permalink":"https://koala99.github.io/tags/cmake/"}]},{"title":"cuda的通信模型","date":"2017-03-03T05:53:53.000Z","path":"2017/03/03/cuda的通信模型/","text":"最近自己的深度学习工作站已经搭起。开始学习cuda。 udacity上课程 cs344cuda根据不同的memory映射方式，我们将task分为以下几种类型：Map, Gather, Scatter, Stencil, transpose. Map: one input - one outputGather: several input - one outpute.g image blur by averageScatter: one input - several outpute.g add a value to its neighbors(因为每个thread 将结果scatter到各个memory，所以叫scatter)stencil: 对input中的每一个位置，stencil input：该点的neighborhood stencil output：该点value e.g image blur by average 这样也可以看出，stencil和gather很像，其实stencil是gather的一种，只不过stencil要求input必须是neighborhood而且对input的每一个元素都要操作 transposeinput：matrix Moutput: M^T","tags":[{"name":"并行计算","slug":"并行计算","permalink":"https://koala99.github.io/tags/并行计算/"},{"name":"cuda","slug":"cuda","permalink":"https://koala99.github.io/tags/cuda/"}]},{"title":"android nkd 的一些注意的地方","date":"2016-11-30T06:27:00.000Z","path":"2016/11/30/android-nkd-的一些注意的地方/","text":"在使用android ndk中，我们定义cpp的一些方法，里面参数类型对应关系对应，值得注意。java内部是使用16bit的unicode编码（UTF-16）来表示字符串的，无论中文英文都是2字节；jni内部是使用UTF-8编码来表示字符串的，UTF-8是变长编码的unicode，一般ascii字符是1字节，中文是3字节；c/c++使用的是原始数据，ascii就是一个字节了，中文一般是GB2312编码，用两个字节来表示一个汉字。列举下jni中一些常见的方法： xtern \"C\" JNIEXPORT jstring JNICALL Java_com_android_ndkdemo_NativeUtils_changeString( JNIEnv *env, jclass,jstring str) { const char *char1 =env->GetStringUTFChars(str, false); string str2(char1); str2+=\"1222\"; env->ReleaseStringUTFChars(str,char1); return env->NewStringUTF(str2.c_str()); } 上面只是稍微简单的字符串传递，还有更麻烦的就是容器类传递，比如list，这里面在jni中，都当做jobject来处理，根据方法获取他们的class，method，最后来调用，可以看下面的例子: Java_com_android_ndkdemo_NativeUtils_changeStringList( JNIEnv *env, jclass, jobject strlist) { //静态方法 GetStaticMethodID jclass cls_arraylist = env->GetObjectClass(strlist); jmethodID arraylist_get = env->GetMethodID(cls_arraylist, \"get\", \"(I)Ljava/lang/Object;\"); jmethodID arraylist_size = env->GetMethodID(cls_arraylist, \"size\", \"()I\"); jmethodID arrayList_add = env->GetMethodID(cls_arraylist, \"add\", \"(Ljava/lang/Object;)Z\"); const char *cc = \"hello\"; jstring jrstr; jrstr = env->NewStringUTF(cc); // env->CallObjectMethod(strlist, arrayList_add, jrstr); env->CallBooleanMethod(strlist, arrayList_add, jrstr); jint len = env->CallIntMethod(strlist, arraylist_size); char buf[64]; sprintf(buf, \"%d\", len); jstring str = env->NewStringUTF(buf); LOGD(env->GetStringUTFChars(str, false)); return strlist; } 如需参考，可以看下github地址：https://github.com/koala99/androidtest/tree/master/ndkdemo","tags":[{"name":"android ndk","slug":"android-ndk","permalink":"https://koala99.github.io/tags/android-ndk/"}]},{"title":"ios 开发小结","date":"2016-09-20T13:54:34.000Z","path":"2016/09/20/ios-开发小结/","text":"很早就接触swift了，之前虽然写过一些简单的demo，但还没系统性完成一个商业app。之前开发完了公司的安卓版产品，没有ios，自己就承担开发ios的版本，算下来，时间比安卓开发稍微长一点，考虑到swift 3版本升级，造成一些库的兼容处理，总体时间上跟安卓开发时间差不多。这里就介绍一些自己用到的一些库。首先是布局方面，ios开发的布局，自己真的很不喜欢，虽然提供了storyboard这样的可视化拖拉，这边自己都是做autolayout,使用的库是Snapkit,自己通过纯代码来实现布局。虽然代码量大，但是写起来比较熟。网络请求之前用原生的来写，做json解析，真的挺麻烦的，后来采用了SwiftHTTP,使用简单。返回数据这边都做了序列化操作，ios中这边采用了ObjectMapper，它来做实体类的序列化，挺方便的。考虑到我们安卓中常常用到的事务总栈eventbus，swift方面也有对应的实现，基于notification来做的封装。 SwiftEventBus 。使用方法也与eventbus类似。一些图像的异步加载，离线缓存，我这边采用的是功能强大的 HanekeSwift ,它的作用远远不止这些。总体而言，因为app上没有涉及太多的复杂功能点，开发起来很顺利，ios的开发架构也跟安卓一致，最大的变数就是swift这本语言，2.0到3.0变化还有有些大的，当然，coder必须适应这些变化，不断学习。","tags":[{"name":"ios","slug":"ios","permalink":"https://koala99.github.io/tags/ios/"},{"name":"swift","slug":"swift","permalink":"https://koala99.github.io/tags/swift/"}]},{"title":"swift 3.0之后的一些变化","date":"2016-09-11T13:47:32.000Z","path":"2016/09/11/swift-3-0之后的一些变化/","text":"由于之前项目都是swift2写的，现在都得做升级，更新到swift3，这边就做下记录。 CGPointMake -> CGPoint let point = CGPoint(x: 0,y :0) // x和y的值可以是CGFloat, Double, Int CGSizeMake -> CGSize let size = CGSize(width: 100, height: 100) // width和height的值可以是CGFloat, Double, Int CGRectMake -> CGRect 用CGPoint和CGSize来构建 let rect = CGRect(origin: CGPoint(x: 0,y :0), size: CGSize(width: 100, height: 100)) 用CGFloat，Double和Int值构建 let rect = CGRect(x: 0, y: 0, width: 100, height: 100) // 参数类型可以为CGFloat, Double, Int CGRectZero->CGRect.zero & CGPointZero -> CGPoint.zero let size = CGSize.zero // width = 0, height = 0 let point = CGPoint.zero // x = 0, y = 0，等同于CGPointZero let rect = CGRect.zero // 等同与 CGRectZero","tags":[{"name":"ios,swift","slug":"ios-swift","permalink":"https://koala99.github.io/tags/ios-swift/"}]},{"title":"cmake配置","date":"2016-05-20T07:52:53.000Z","path":"2016/05/20/cmake配置/","text":"之前在mac上，开发c++，一向都是用qt creator，现在在ubuntu上开发，做opencv相关的学习，自己也把qmake改成强大的cmake了，结果发现一直找不到c的编译器，很是奇怪（系统由14.04升级到16.04）： No CMAKE_C_COMPILER could be found 终端里面命令： which gcc 也能找到路径。 最终没辙，只得在环境变量中定义才解决。至于为啥会造成找不到gcc路径，目前还不清楚，先记录下这个问题。","tags":[{"name":"日常记录","slug":"日常记录","permalink":"https://koala99.github.io/tags/日常记录/"},{"name":"ubuntu","slug":"ubuntu","permalink":"https://koala99.github.io/tags/ubuntu/"}]},{"title":"opencv的安装和配置","date":"2016-05-17T13:15:30.000Z","path":"2016/05/17/opencv的安装和配置/","text":"opencv是计算机视觉处理必备，自己趁这段时间工作不是很繁忙，也开始学习下。1 预先安装一些软件： sudo apt-get install build-essential cmake libgtk2.0-dev pkg-config python-dev python-numpy libavcodec-dev libavformat-dev libswscale-dev2 去管网下载opencv压缩包 3 解压压缩包到某文件夹（用windows习惯了，直接右键提取到此处。。。） 4 command中cd到该解压缩的文件夹中，然后创建build文件夹 mkdir build 5 进入build目录 cd build 6 编译opencv源码 cmake -D CMAKE_BUILD_TYPE=RELEASE -D CMAKE_INSTALL_PREFIX=/usr/local .. 7 安装 sudo make install 自己环境配置是ubuntu+qt+opencv， opencv直接官网下载，源码编译安装，这部分就不用介绍了，值得注意的是，在qt creator中引用libs库时，需在.pro文件中做如下配置： INCLUDEPATH += /usr/local/include\\ /usr/local/include/opencv\\ /usr/local/include/opencv2LIBS += -L/usr/local/lib -lopencv_core -lopencv_imgcodecs -lopencv_highgui TEMPLATE = appCONFIG += console c++11CONFIG -= app_bundleCONFIG -= qt SOURCES += main.cpp环境配置好了，后面继续学习。","tags":[{"name":"opencv ubuntu","slug":"opencv-ubuntu","permalink":"https://koala99.github.io/tags/opencv-ubuntu/"}]},{"title":"机器学习入门系列_knn","date":"2015-04-11T12:56:00.000Z","path":"2015/04/11/knn算法和应用/","text":"knn也就是K最近邻算法，采用测量不同特征值之间的距离方法进行分类，具体操作流程也就分以下几步： 1:计算已知类别数据集中的点与当前点的距离 2：按照距离递增排序 3：选取与当前距离最小的k个点 4：确认前k个点所在类别的出现频率 5：返回前k个点出现频率最高的类别作为当前点的预测分类 书上第一张也给出了一个简单的knn测试,里面引用了numpy库,源码如下: from numpy import *import operatorfrom os import listdirdef classify0(inX, dataSet, labels, k): # 计算距离 #获取dataSet的长度 dataSetSize = dataSet.shape[0] #生成新的矩阵，减去存在的矩阵 diffMat = tile(inX, (dataSetSize,1)) - dataSet #矩阵元素平方 sqDiffMat = diffMat**2 #axis=1 行相加， axis=0 列相加 sqDistances = sqDiffMat.sum(axis=1) #开方 distances = sqDistances**0.5 #函数是将x中的元素从小到大排列，提取其对应的index(索引) sortedDistIndicies = distances.argsort() print(sortedDistIndicies) #选择距离最小的k个点 classCount={} for i in range(k): print(sortedDistIndicies[i]) voteIlabel = labels[sortedDistIndicies[i]] print(voteIlabel) classCount[voteIlabel] = classCount.get(voteIlabel,0) + 1 print(classCount) #排序 sortedClassCount = sorted(classCount.iteritems(), key=operator.itemgetter(1), reverse=True) print(sortedClassCount) return sortedClassCount[0][0] def createDataSet(): group = array([[1.0,1.1],[1.0,1.0],[0,0],[0,0.1]]) labels = [‘A’,’A’,’B’,’C’] return group, labelsif name == “main“: data = createDataSet() print(classify0([0,0],data[0],data[1],3))","tags":[{"name":"机器学习","slug":"机器学习","permalink":"https://koala99.github.io/tags/机器学习/"}]},{"title":"机器学习入门系列_准备篇","date":"2015-04-10T11:52:53.000Z","path":"2015/04/10/机器学习初学/","text":"现在公司的一个留美回来的博士就是美国那边做机器学习方面的工作，当时感觉还挺有意思的，觉得机器学习也很有前途的，于是还买了一本图解学习的书看了下，奈何里面都是公式的推导，看的懵逼懵逼的。 可能我擅长实践但是缺乏理论，于是乎，趁最近工作不是很繁忙，自己重新捡回来了大学的高数，概率论和线性代数。 首先记录下机器学习的一些数学基本知识。 高数：常见函数求导导数运算法则复合函数求导方向导数与梯度（难点）凸集与凸函数一元函数求极值多元函数求极值（了解）拉格朗日乘子法泰勒公式展开空间解析几何和向量代数 线性代数 线性代数：矩阵的定义，矩阵的转置单位矩阵，三角矩阵，对称矩阵向量内积，相关性正交向量组，标准正交基，正交矩阵特征值分解 概率论事件的关系与运算：条件概率，全概率公式，贝叶斯公式随机变量的期望，方差协方差，相关系数，协方差矩阵概率分布：0-1分布，二项分布，高斯分布极大似然函数估计大数定律，伯努利大数定律，中心极限定理 这次，自己又买了一本machine learning in action的书籍，从它开始一步一步学习。","tags":[{"name":"机器学习","slug":"机器学习","permalink":"https://koala99.github.io/tags/机器学习/"}]},{"title":"NumPy常用的函数库","date":"2015-03-05T02:15:01.000Z","path":"2015/03/05/NumPy常用的函数库/","text":"创建二维数组 array()：array = ones(5)array = [1,1,1,1,1]array = empty(5)使用ones可以创建任意维度和元素个数的数组，其元素均为1。zeros（） 全是0 的矩阵，empty函数的使用方法一样，只是它创建的是数组所有元素均为空，所以它是速度最快的创建数组的方法。set = array([[1., 2, ],[3., 4.],[5., 6.],[7., 9.]]) 求数组的 行数： set.shape[0] 4求数组的列数：set.shape[1] 2求数组的大小 set.shape(4, 2)求数组的类型 set.dtypedtype(‘float64’) numpy.eye(N,M=None, k=0, dtype=) 关注第一个第三个参数就行了 第一个参数：输出方阵（行数=列数）的规模，即行数或列数 第三个参数：默认情况下输出的是对角线全“1”，其余全“0”的方阵，如果k为正整数，则在右上方第k条对角线全“1”其余全“0”，k为负整数则在左下方第k条对角线全“1”其余全“0”。 创建矩阵 identity() tile(1,2)： array([1, 1]) tile((1,2,3),3)： array([1, 2, 3, 1, 2, 3, 1, 2, 3]) b=[1,3,5] tile(b,[2,3])： array([[1, 3, 5, 1, 3, 5, 1, 3, 5], [1, 3, 5, 1, 3, 5, 1, 3, 5]]) c = np.array([[0, 2, 1], [3, 5, 6], [0, 1, 1]]) print c.sum()print c.sum(axis=0)print c.sum(axis=1) 结果分别是：19, [3 8 8], [ 3 14 2] 函数是将x中的元素从小到大排列，提取其对应的index(索引)array.argsort() Out[4]: array([3, 2, 0, 1]) x = np.array([[0, 3], [2, 2]])： array([[0, 3], [2, 2]]) np.argsort(x, axis=0) #按列排序 array([[0, 1], [1, 0]]) np.argsort(x, axis=1) #按行排序 array([[0, 1], [0, 1]])","tags":[{"name":"机器学习","slug":"机器学习","permalink":"https://koala99.github.io/tags/机器学习/"},{"name":"numpy","slug":"numpy","permalink":"https://koala99.github.io/tags/numpy/"}]},{"title":"android架构浅谈","date":"2014-11-13T13:30:20.000Z","path":"2014/11/13/android架构浅谈/","text":"从做安卓开始，心中最熟悉的还是mvc这中架构，上大学那会，自己写最初写java web那会，就是构造java bean，jsp做展现，servlet做控制器，慢慢到后来，随着用到ssh这些框架，分层也越来越细了。写了两年多的安卓，基本还是沿用mvc框架来处理问题。今年开始流行起来mvp这个框架了，这个框架最初还是在微软.net平台上实践，慢慢有人就开始用到安卓上来了。为什么要用mvp？肯定还是android上mvc不够好，首先我们来看这个模型图：明显可以注意到 这三层形成了一个回路，耦合度高。看看android上mvc的实现，View层：定义View或ViewGroup或xml，负责将用户的请求通知Controller，并根据model更新界面；Controller层：我们的activity或者fragment这个根据model更改界面；model：最常见的java bean和网络回传的数据看似划分的很清楚，其实问题就出在activity或fragment上，他们里面也有大量处理ui的代码，页面操作也在这里面，从而造成耦合度过高，一个很简单的例子，我们定义了很多button，每个button的的动作监听需要在activity中，监听后改变ui也在activity中，一旦控件过多，activity就很膨胀。于是我们就开始引出mvp了，他实际上是mvc的改造，看图说话：最大的区别就是model与view完全解绑了，不会打交道了。view就是我们那些xml，activity，presenter处理具体业务model不变。这里可能出问题的就是presenter对activity或fragment的引用，一般采用弱引用来解决这个问题。总结下它们的处理流程:在MVC中，用户的请求首先会到达Controller,有Controller从Model获取数据，选择合适的View,把处理结果呈现到View上；在MVP中，用户的请求首先会到达View,View传递请求到特定的Presenter,Presenter从Model获取数据后，再把处理结果通过接口传递到View。","tags":[]},{"title":"tcp的三次握手，四次挥手","date":"2014-10-18T08:24:30.000Z","path":"2014/10/18/tcp的三次握手，四次挥手/","text":"TCP的传输连接分为3个阶段：连接建立（三次握手）、数据传送和连接释放（四次挥手）。TCP传输连接的管理就是使传输连接的建立和释放都能正常地进行。准备工作：服务器必须准备好接受外来的连接。这通常通过调用socket,bind和listen这三个函数来完成。我们称之为被动打开。第一次握手：客户端通过调用connect发起主动打开。客户端向服务器发出连接请求的TCP报文段，其TCP首部中的同步比特SYN置为1，并TCP首部中序号seq设置为x（TCP规定SYN报文段不能携带数据，但是要消耗一个序号），表明要转送数据时初始序列号是x。通常SYN分节不携带数据，其所在IP数据报只含有一个IP首部，一个TCP首部。 第二次握手：服务器收到数据报后，从TCP数据报首部的同步比特SYN位为1就知道这是一个建立连接的请求。服务器如果同意，会发回确认。在确认报文段中把同步比特位SYN设置为1，确认比特位ACK设置为1，由于TCP请求报文段中的序号是x，所以服务器在发送确认报文段中的确认号ack是x+1，同时把确认报文段中的序号seq设置为y，表明服务器发送数据的初始序列号为y。该报文段也不能携带数据（因为SYN=1，所以不携带任何数据）。 第三次握手：客户端收到服务器端的报文段后，要对服务器端中的SYN进行确认。在确认报文段中把确认比特位ACK设置为1，然后把确认号ack设置为y+1，自身的序号seq设置x+1。注：客户的初始序列号为x,服务器的初始序列号为y，那么确认报文段中的确认号ack就是所期待的对方要发送的下一个序列号。 数据传输完毕后，通信双方都可以释放连接。对于首先调用close的一端我们称该端为主动关闭，另外一端执行被动关闭。 第一次挥手：假设客户端执行主动关闭，那么它会向服务器端发出释放连接的报文段，这个TCP报文段中终止比特FIN置为1，序号seq设置为u（假设上一个发的数据序号是u-1）。并停止发送数据。主动关闭TCP连接。等待服务器的确认，这里需要注意，因为TCP是全双工的，所以TCP连接上有两条数据通路，发送FIN的一端就不能发送数据，也就是关闭了其中一条数据通路，对方还是可以继续发送数据。 第二次挥手：服务器端收到客户端的释放连接的报文段后会执行被动关闭，它要对客户端的数据报进行确认，服务器端会发送一个确认的数据报，确认比特ACK设置为1，确认号为u+1，自身的序号seq为v(假设上一个发的数据序号是v-1)。这个时候TCP处于半关闭状态，服务器依然可以向客户端发送数据（数据的序号为v+1 ~ w-1），客户端任要接受。 第三次挥手：服务器端已经没有要发送给客户端的数据，那么服务器端也会调用close关闭套接字，这样服务器端也会发送一个FIN的TCP报文段，序号是w（假设上一个发的数据序号是w-1）。这个时候服务器端不会再向客户端发送数据了。 第四次挥手：客户端接受到这个最终的FIN的释放连接报文段后必须对报文段进行确认。在确认的报文段中，ACK=1,确认序号ack=w+1，自己的序号seq=u+1(他的上一个序号的数据报就是申请释放连接的数据报，序号是seq=u)。 为什么TCP握手是三次，挥手却是四次？（假设客户端主动，服务器端被动）在TCP三次握手中，服务器端的SYN和ACK是放在一个TCP报文段中向客户端发送的，而在断开连接的过程中，服务器端向客户单端发送的ACK和FIN是是分别在两个不同的TCP报文段中。这是因为在服务器端接收到客户端的FIN后，服务器端可能还有数据要传输，所以先发送ACK，服务器端把数据发完之后就可以发送FIN断开连接了。","tags":[{"name":"java","slug":"java","permalink":"https://koala99.github.io/tags/java/"},{"name":"tcp","slug":"tcp","permalink":"https://koala99.github.io/tags/tcp/"}]},{"title":"reentrantlock与synchronized对比","date":"2014-10-16T10:24:30.000Z","path":"2014/10/16/reentrantlock与synchronized对比/","text":"锁作为并发共享数据，保证一致性的工具，在JAVA平台有多种实现，我们常用的就是synchronized 和 ReentrantLock。相同点，他们都属于可重入锁，可重入锁，也叫做递归锁，指的是同一线程 外层函数获得锁之后 ，内层递归函数仍然有获取该锁的代码，但不受影响。可以看下面简单的例子： public class Test implements Runnable{ public synchronized void get(){ System.out.println(Thread.currentThread().getId()); set(); } public synchronized void set(){ System.out.println(Thread.currentThread().getId()); } @Override public void run() { get(); } public static void main(String[] args) { Test ss=new Test(); new Thread(ss).start(); new Thread(ss).start(); new Thread(ss).start(); }} public class Test implements Runnable { ReentrantLock lock = new ReentrantLock(); public void get() { lock.lock(); System.out.println(Thread.currentThread().getId()); set(); lock.unlock(); } public void set() { lock.lock(); System.out.println(Thread.currentThread().getId()); lock.unlock(); } @Override public void run() { get(); } public static void main(String[] args) { Test ss = new Test(); new Thread(ss).start(); new Thread(ss).start(); new Thread(ss).start(); }}两个例子最后的结果都是正确的，即 同一个线程id被连续输出两次。可重入锁最大的作用是避免死锁. 1、ReentrantLock 拥有Synchronized相同的并发性和内存语义，此外还多了 锁投票，定时锁等候和中断锁等候线程A和B都要获取对象O的锁定，假设A获取了对象O锁，B将等待A释放对O的锁定，如果使用 synchronized ，如果A不释放，B将一直等下去，不能被中断如果 使用ReentrantLock，如果A不释放，可以使B在等待了足够长的时间以后，中断等待，而干别的事情 ReentrantLock获取锁定与三种方式：a) lock(), 如果获取了锁立即返回，如果别的线程持有锁，当前线程则一直处于休眠状态，直到获取锁b) tryLock(), 如果获取了锁立即返回true，如果别的线程正持有锁，立即返回false；c)tryLock(long timeout,TimeUnit unit)， 如果获取了锁定立即返回true，如果别的线程正持有锁，会等待参数给定的时间，在等待的过程中，如果获取了锁定，就返回true，如果等待超时，返回false；d) lockInterruptibly:如果获取了锁定立即返回，如果没有获取锁定，当前线程处于休眠状态，直到或者锁定，或者当前线程被别的线程中断 2、synchronized是在JVM层面上实现的，不但可以通过一些监控工具监控synchronized的锁定，而且在代码执行时出现异常，JVM会自动释放锁定，但是使用Lock则不行，lock是通过代码实现的，要保证锁定一定会被释放，就必须将unLock()放到finally{}中 3、在资源竞争不是很激烈的情况下，Synchronized的性能要优于ReetrantLock，但是在资源竞争很激烈的情况下，Synchronized的性能会下降几十倍，但是ReetrantLock的性能能维持常态； 5.0的多线程任务包对于同步的性能方面有了很大的改进，在原有synchronized关键字的基础上，又增加了ReentrantLock，以及各种Atomic类。了解其性能的优劣程度，有助与我们在特定的情形下做出正确的选择。 总体的结论先摆出来： synchronized：在资源竞争不是很激烈的情况下，偶尔会有同步的情形下，synchronized是很合适的。原因在于，编译程序通常会尽可能的进行优化synchronize，另外可读性非常好，不管用没用过5.0多线程包的程序员都能理解。 ReentrantLock:ReentrantLock提供了多样化的同步，比如有时间限制的同步，可以被Interrupt的同步（synchronized的同步是不能Interrupt的）等。在资源竞争不激烈的情形下，性能稍微比synchronized差点点。但是当同步非常激烈的时候，synchronized的性能一下子能下降好几十倍。而ReentrantLock确还能维持常态。","tags":[{"name":"java","slug":"java","permalink":"https://koala99.github.io/tags/java/"},{"name":"多线程","slug":"多线程","permalink":"https://koala99.github.io/tags/多线程/"}]},{"title":"java多线程详解","date":"2014-10-15T08:24:30.000Z","path":"2014/10/15/java多线程详解/","text":"公司的背单词软件，大量用到多线程技术。这边就自己做个总结。首先我们要清楚线程的概念，别让它与进程搞混淆。 进程：每个进程都有独立的代码和数据空间（进程上下文），进程间的切换会有较大的开销，一个进程包含1–n个线程。（进程是资源分配的最小单位） 线程：同一类线程共享代码和数据空间，每个线程有独立的运行栈和程序计数器(PC)，线程切换开销小。（线程是cpu调度的最小单位） 线程的五种状态：创建，就绪，运行，阻塞，终止 在java中要想实现多线程，有三种手段，一种是继续Thread类，另外一种是实现Runable接口.还有一种是实现Callable接口，并与Future、线程池结合使用。Thread和Runnable的区别如果一个类继承Thread，则不适合资源共享。但是如果实现了Runable接口的话，则很容易的实现资源共享。总结：实现Runnable接口比继承Thread类所具有的优势： 1）：适合多个相同的程序代码的线程去处理同一个资源 2）：可以避免java中的单继承的限制 3）：增加程序的健壮性，代码可以被多个线程共享，代码和数据独立 4）：线程池只能放入实现Runable或callable类线程，不能直接放入继承Thread的类一些常用的方法：①sleep(long millis): 在指定的毫秒数内让当前正在执行的线程休眠（暂停执行）②join():指等待t线程终止。③yield():暂停当前正在执行的线程对象，并执行其他线程。sleep()和yield()的区别):sleep()使当前线程进入停滞状态，所以执行sleep()的线程在指定的时间内肯定不会被执行；yield()只是使当前线程重新回到可执行状态，所以执行yield()的线程有可能在进入到可执行状态后马上又被执行。④setPriority(): 更改线程的优先级。⑤interrupt():不要以为它是中断某个线程！它只是线线程发送一个中断信号，让线程在无限等待时（如死锁时）能抛出抛出，从而结束线程，但是如果你吃掉了这个异常，那么这个线程还是不会中断的！wait和sleep区别共同点： 他们都是在多线程的环境下，都可以在程序的调用处阻塞指定的毫秒数，并返回。 wait()和sleep()都可以通过interrupt()方法 打断线程的暂停状态 ，从而使线程立刻抛出InterruptedException。如果线程A希望立即结束线程B，则可以对线程B对应的Thread实例调用interrupt方法。如果此刻线程B正在wait/sleep /join，则线程B会立刻抛出InterruptedException，在catch() {} 中直接return即可安全地结束线程。需要注意的是，InterruptedException是线程自己从内部抛出的，并不是interrupt()方法抛出的。对某一线程调用 interrupt()时，如果该线程正在执行普通的代码，那么该线程根本就不会抛出InterruptedException。但是，一旦该线程进入到 wait()/sleep()/join()后，就会立刻抛出InterruptedException 。不同点： Thread类的方法：sleep(),yield()等Object的方法：wait()和notify()等 每个对象都有一个锁来控制同步访问。Synchronized关键字可以和对象的锁交互，来实现线程的同步。sleep方法没有释放锁，而wait方法释放了锁，使得其他线程可以使用同步控制块或者方法。 wait，notify和notifyAll只能在同步控制方法或者同步控制块里面使用，而sleep可以在任何地方使用 sleep必须捕获异常，而wait，notify和notifyAll不需要捕获异常所以sleep()和wait()方法的最大区别是：sleep()睡眠时，保持对象锁，仍然占有该锁；而wait()睡眠时，释放对象锁。但是wait()和sleep()都可以通过interrupt()方法打断线程的暂停状态，从而使线程立刻抛出InterruptedException（但不建议使用该方法）。sleep（）方法sleep()使当前线程进入停滞状态（阻塞当前线程），让出CUP的使用、目的是不让当前线程独自霸占该进程所获的CPU资源，以留一定时间给其他线程执行的机会; sleep()是Thread类的Static(静态)的方法；因此他不能改变对象的机锁，所以当在一个Synchronized块中调用Sleep()方法是，线程虽然休眠了，但是对象的机锁并木有被释放，其他线程无法访问这个对象（即使睡着也持有对象锁）。 在sleep()休眠时间期满后，该线程不一定会立即执行，这是因为其它线程可能正在运行而且没有被调度为放弃执行，除非此线程具有更高的优先级。wait（）方法wait()方法是Object类里的方法；当一个线程执行到wait()方法时，它就进入到一个和该对象相关的等待池中，同时失去（释放）了对象的机锁（暂时失去机锁，wait(long timeout)超时时间到后还需要返还对象锁）；其他线程可以访问； wait()使用notify或者notifyAlll或者指定睡眠时间来唤醒当前等待池中的线程。 wiat()必须放在synchronized block中，否则会在program runtime时扔出”java.lang.IllegalMonitorStateException“异常。线程同步1、synchronized关键字的作用域有二种：1）是某个对象实例内，synchronized aMethod(){}可以防止多个线程同时访问这个对象的synchronized方法（如果一个对象有多个synchronized方法，只要一个线程访问了其中的一个synchronized方法，其它线程不能同时访问这个对象中任何一个synchronized方法）。这时，不同的对象实例的synchronized方法是不相干扰的。也就是说，其它线程照样可以同时访问相同类的另一个对象实例中的synchronized方法； 2）是某个类的范围，synchronized static aStaticMethod{}防止多个线程同时访问这个类中的synchronized static 方法。它可以对类的所有对象实例起作用。 2、除了方法前用synchronized关键字，synchronized关键字还可以用于方法中的某个区块中，表示只对这个区块的资源实行互斥访问。用法是: synchronized(this){/区块/}，它的作用域是当前对象； 3、synchronized关键字是不能继承的，也就是说，基类的方法synchronized f(){} 在继承类中并不自动是synchronized f(){}，而是变成了f(){}。继承类需要你显式的指定它的某个方法为synchronized方法；synchronized关键字不能继承。一个线程访问一个对象的synchronized代码块时，别的线程可以访问该对象的非synchronized代码块而不受阻塞。无论synchronized关键字加在方法上还是对象上，如果它作用的对象是非静态的，则它取得的锁是对象；如果synchronized作用的对象是一个静态方法或一个类，则它取得的锁是对类，该类所有的对象同一把锁。每个对象只有一个锁（lock）与之相关联，谁拿到这个锁谁就可以运行它所控制的那段代码。实现同步是要很大的系统开销作为代价的，甚至可能造成死锁，所以尽量避免无谓的同步控制。Java语言提供了一种稍弱的同步机制，即volatile变量，用来确保将变量的更新操作通知到其他线程。当把变量声明为volatile类型后，编译器与运行时都会注意到这个变量是共享的，因此不会将该变量上的操作与其他内存操作一起重排序。volatile变量不会被缓存在寄存器或者对其他处理器不可见的地方，因此在读取volatile类型的变量时总会返回最新写入的值。您只能在有限的一些情形下使用 volatile 变量替代锁。要使 volatile 变量提供理想的线程安全，必须同时满足下面两个条件： 对变量的写操作不依赖于当前值。该变量没有包含在具有其他变量的不变式中。实际上，这些条件表明，可以被写入 volatile 变量的这些有效值独立于任何程序的状态，包括变量的当前状态。","tags":[{"name":"java","slug":"java","permalink":"https://koala99.github.io/tags/java/"},{"name":"多线程","slug":"多线程","permalink":"https://koala99.github.io/tags/多线程/"}]},{"title":"java gc原理","date":"2014-10-13T12:24:30.000Z","path":"2014/10/13/java gc原理/","text":"作为android开发人员，了解java的GC工作原理很有必要。我们开发的app需要不断的优化，这就包括如何优化GC的性能、如何与GC进行有限的交互。 这边就从一个简单的demo展开。在idea 运行中配置如下代码: -server -Xms10m -Xmx10m -XX:+DoEscapeAnalysis -XX:+PrintGc 这边先介绍几个概念： -Xms 10m，表示JVM Heap(堆内存)最小尺寸10MB，最开始只有 -Xms 的参数，表示 初始 memory size(m表示memory，s表示size)，属于初始分配10m，-Xms表示的 初始 内存也有一个 最小 内存的概念（其实常用的做法中初始内存采用的也就是最小内存）。 -Xmx 10m，表示JVM Heap(堆内存)最大允许的尺寸10MB，按需分配。如果 -Xmx 不指定或者指定偏小，也许出现java.lang.OutOfMemory错误，此错误来自JVM不是Throwable的，无法用try…catch捕捉。 DoEscapeAnalysis 逃逸模式，前面+代表启用，-号代表关闭 PrintGc 打印gc信息 测试代码如下： public class Test { /** * 内分配了两个字节的内存空间 */ public static void alloc(){ int[] array = new int[2]; array[0] = 1; } public static void main(String[] args) { long startTime = System.currentTimeMillis(); // 分配 100000000 个 alloc 分配的内存空间 for(int i = 0; i &lt; 100000000; i++){ alloc(); } long endTime = System.currentTimeMillis(); System.out.println(endTime - startTime); } } 可以看到跟踪的gc信息，一连串如下： [GC (Allocation Failure) 2472K-&gt;424K(9728K), 0.0030868 secs] 看起来还不够详细，可以继续配置如下命令 -XX:+PrintGCDetails，运行可以看到如下结果： [GC (Allocation Failure) [PSYoungGen: 2048K-&gt;0K(2560K)] 2488K-&gt;440K(9728K), 0.0003446 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]1832Heap PSYoungGen total 2560K, used 1515K [0x00000007bfd00000, 0x00000007c0000000, 0x00000007c0000000) eden space 2048K, 73% used [0x00000007bfd00000,0x00000007bfe7ad80,0x00000007bff00000) from space 512K, 0% used [0x00000007bff80000,0x00000007bff80000,0x00000007c0000000) to space 512K, 0% used [0x00000007bff00000,0x00000007bff00000,0x00000007bff80000) ParOldGen total 7168K, used 440K [0x00000007bf600000, 0x00000007bfd00000, 0x00000007bfd00000) object space 7168K, 6% used [0x00000007bf600000,0x00000007bf66e050,0x00000007bfd00000) Metaspace used 2991K, capacity 4494K, committed 4864K, reserved 1056768K class space used 327K, capacity 386K, committed 512K, reserved 1048576K 看最后的heap总结，这里就可以看到划分去了几个generation，PSYoungGen ParOldGen Metaspace，Metaspace，在jdk1.8中， Permanent Generation已经取代了Metaspace， young gen中就有我们熟悉的伊甸区 eden space，关于各区的介绍，这里详细的概述下： JVM在程序运行过程当中，会创建大量的对象，这些对象，大部分是短周期的对象，小部分是长周期的对象，对于短周期的对象，需要频繁地进行垃圾回收以保证无用对象尽早被释放掉，对于长周期对象，则不需要频率垃圾回收以确保无谓地垃圾扫描检测。为解决这种矛盾，Sun JVM的内存管理采用分代的策略。 1）年轻代(Young Gen)：年轻代主要存放新创建的对象，内存大小相对会比较小，垃圾回收会比较频繁。年轻代分成1个Eden Space和2个Suvivor Space（命名为A和B）。当对象在堆创建时，将进入年轻代的Eden Space。垃圾回收器进行垃圾回收时，扫描Eden Space和A Suvivor Space，如果对象仍然存活，则复制到B Suvivor Space，如果B Suvivor Space已经满，则复制到Old Gen。同时，在扫描Suvivor Space时，如果对象已经经过了几次的扫描仍然存活，JVM认为其为一个持久化对象，则将其移到Old Gen。扫描完毕后，JVM将Eden Space和A Suvivor Space清空，然后交换A和B的角色（即下次垃圾回收时会扫描Eden Space和BSuvivor Space。这么做主要是为了减少内存碎片的产生。 我们可以看到：Young Gen垃圾回收时，采用将存活对象复制到到空的Suvivor Space的方式来确保尽量不存在内存碎片，采用空间换时间的方式来加速内存中不再被持有的对象尽快能够得到回收。2）年老代(Tenured Gen)：年老代主要存放JVM认为生命周期比较长的对象（经过几次的Young Gen的垃圾回收后仍然存在），内存大小相对会比较大，垃圾回收也相对没有那么频繁（譬如可能几个小时一次）。年老代主要采用压缩的方式来避免内存碎片（将存活对象移动到内存片的一边，也就是内存整理）。当然，有些垃圾回收器（譬如CMS垃圾回收器）出于效率的原因，可能会不进行压缩。3）持久代(Perm Gen)：持久代主要存放类定义、字节码和常量等很少会变更的信息。 了解了这些，其实我们也该清楚一些优化的方法，为什么常量不宜太多，年轻区的内存空间应该大，太小了，操作频繁的数据都会进入年老区，垃圾回收不频繁。 言归正传，继续谈我们的GC，首先讲下我们的垃圾回收算法，古老的引用计数法。它的基本思想很简单，对于一个对象A，只要有任何一个对象引用了A，则A的引用计数器就加1，当引用失效时，引用计数器就减1。只要对象A的引用计数器的值为0，则对象A就不可能再被使用。就可以回收了。它的缺点也很明显，1，每次引用和去引用都需要加减，性能不行；2循环引用问题，可以看下简单代码。 class A{ public B b; }class B{ public A a;}public class Main{ public static void main(String[] args){ A a = new A(); B b = new B(); a.b=b; b.a=a; }} 这种情况下，谁都没法回收。java的垃圾回收使用的基本的算法思想是标记-清除算法： 标记-清除算法是现代垃圾回收算法的思想基础。将垃圾回收分为两个阶段：标记阶段和清除阶段。 一种可行的实现是，在标记阶段，首先通过根节点，标记所有从根节点开始的可达对象（从GC ROOT开始标记引用链——又叫可达性算法）。因此，未被标记的对象就是未被引用的垃圾对象。然后，在清除阶段，清除所有未被标记的对象。这样就不怕循环问题了。 具体效果图如下： 这种算法的缺点就是容易出现内存碎片。利用率不高。要知道，现代的Java虚拟机都是使用的分代回收的设计，比如在标记-清除算法的基础上做了一些优化的——标记-压缩算法，适合用于存活对象较多的场合，如老年代。 和标记-清除算法一样，标记-压缩算法也首先需要从根节点开始，对所有可达对象做一次标记。但之后，它并不简单的清理未标记的对象，而是将所有的存活对象压缩到内存的一端。之后，清理边界外所有的空间。有效解决内存碎片问题。 和标记-清除算法相比，复制算法是一种相对高效的回收方法，但是 不适用于存活对象较多的场合如老年代，使用在新生代， 原理是 将原有的内存空间分为两块，两块空间完全相同，每次只用一块，在垃圾回收时，将正在使用的内存中的存活对象复制到未使用的内存块中，之后，清除正在使用的内存块中的所有对象，交换两个内存的角色，完成垃圾回收。同样也没有内存 碎片产生。 复制算法的缺点是内存的浪费，因为每次只是使用了一般的空间， 而大多数存活对象都在老年代，故复制算法不用在老年代，老年代是Java堆的空间的担保地区。复制算法主要用在新生代。在垃圾回收的时候，大对象直接从新生代进入了老年代存放，大对象一般不使用复制算法，因为一是太大，复制效率低，二是过多的大对象，会使得小对象复制的时候无地方存放。还有被长期引用的对象也放在了老年代。 Java的垃圾回收机制使用的是分代的思想。 依据对象的存活周期进行分类，短命对象归为新生代，长命对象归为老年代。根据不同代的特点，选取合适的收集算法。少量对象存活（新生代，朝生夕死的特性），适合复制算法，大量对象存活（老年代，生命周期很长，甚至和应用程序存放时间一样），适合标记清理或者标记压缩算法。","tags":[{"name":"java","slug":"java","permalink":"https://koala99.github.io/tags/java/"},{"name":"垃圾回收","slug":"垃圾回收","permalink":"https://koala99.github.io/tags/垃圾回收/"}]},{"title":"lbs开发中遇到的问题","date":"2014-09-15T11:09:03.000Z","path":"2014/09/15/lbs开发中遇到的问题/","text":"在开发莫比动力中，遇到了一些问题，这边记录下，莫比动力采用的是百度地图的sdk进行定位服务，根据运动状况，记录运动轨迹。 首先必不可少遇到轨迹漂移的问题，个别轨迹漂移的问题还好解决，有时候就怕遇到长时间轨迹漂移的情况。 当个别位置漂移时，这边主要根据运动状态做了地址栅栏（在规定半径形成的圆中），如果不在此范围内，算作gps漂移，像静止状态下，速度立刻置零，而且不进行更新地图上的经纬度；运动状态时，就需要根据运动速度，首先判断速度，类似那种超大速度，超大距离的点（与速度相关），都需要过滤掉。 长时间漂移这边处理的方法，这边采用的是从第一个异常点开始计算，一定时间内，连续的出现异常点大于20这个边界值，就把这段时间的内统一清空，看做长时间漂移。 在地图上展现轨迹时，如果把记录的点直接描点连线的话，会发现基本都是很突兀的直线连接，这边就需要采用 滑动平均平滑 算法，它的实现很简单，相邻5个点一组，进行计算: 这样绘制的曲线就更加平滑了。","tags":[{"name":"lbs","slug":"lbs","permalink":"https://koala99.github.io/tags/lbs/"},{"name":"优化","slug":"优化","permalink":"https://koala99.github.io/tags/优化/"}]},{"title":"cpp的一些常见问题","date":"2014-09-10T10:52:53.000Z","path":"2014/09/10/cpp的一些常见问题/","text":"大学那会学的cpp，到现在已经很少用到了，由于12年毕业至今一直写安卓，使用的是java语言，所以淡忘了cpp里面许多的概念。这边自己来记录下。 1.一个比较经典的问题——问以下两种声明的区别： const char p 与 char const p 这个问题实质就是考察你对const的理解,const 是用于修饰常量，所以前者p是指向常量字符的指针，不变的是char的值。 后者p是一个指向字符的常量指针，不变的是p的值，即该指针不能再指向别的。 指针与引用的共同点与区别相同点，都是地址的概念。 指针指向一块内存，它的内容是所指内存的地址；引用是某块内存的别名。不同点： 指针是一个实体，而引用仅是个别名；引用使用时无需解引用（），指针需要解引用；引用只能在定义时被初始化一次，之后不可变；指针可变； 引用没有 const，指针有 const，const 的指针不可变；引用不能为空，指针可以为空.3.深拷贝与浅拷贝简单的说，一个对象复制另一个对象，并开辟内存空间，这就叫深拷贝，如果没有开辟新的内存空间，只是类似指针指向的，就是浅拷贝4.野指针野指针是变量没有被初始化。任何指针变量刚被创建时不会自动成为NULL指针，它的缺省值是随机的，它会乱指一气。所以，指针变量在创建的同时应当被初始化，要么将指针设置为NULL，要么让它指向合法的内存。5.sizeof与strlen的区别char str[20]=”0123456789”;int a=strlen(str); a=10;strlen 计算字符串的长度，以\\0’为字符串结束标记。int b=sizeof(str); b=20;sizeof 计算的则是分配的数组str[20] 所占的内存空间的大小，不受里面存储的内容影响再看下面的：（64位编译器下面）char str1=”absde”;char str2[]=”absde”;char str3[8]={‘a’,};char ss[] = “0123456789”; sizeof(str1)=8sizeof(str2)=6;sizeof(str3)=8;sizeof(ss)=11 首先说明一点，char类型占一个字节，所以sizeof(char)是1，这点要理解str1是一个指针，只是指向了字符串”absde”而已。所以sizeof(str1)不是字符串占的空间也不是字符数组占的空间，而是一个字符型指针占的空间。所以sizeof(str1)=sizeof(char)=8，在C/C++中一个指针占8个字节str2是一个字符型数组。C/C++规定，对于一个数组，返回这个数组占的总空间，所以sizeof(str2)取得的是字符串”absde”占的总空间。”absde”中，共有a b s d e \\0六个字符，所以str2数组的长度是6，所以sizeof(str2)=6sizeof(char)=6str3已经定义成了长度是8的数组，所以sizeof(str3)为8str4和str2类似，’0’ ‘1’ … ‘9’加上’\\0’共11个字符，所以ss占的空间是8 后续更新…","tags":[{"name":"日常记录","slug":"日常记录","permalink":"https://koala99.github.io/tags/日常记录/"},{"name":"cpp","slug":"cpp","permalink":"https://koala99.github.io/tags/cpp/"}]},{"title":"hashmap详解","date":"2014-08-03T13:30:30.000Z","path":"2014/08/03/java hashmap原理/","text":"hashmap在java中，我们一般面试中会经常问到:1.什么时候会使用HashMap？他有什么特点？2.你知道HashMap的工作原理吗？3.你知道get和put的原理吗？equals()和hashCode()的都有什么作用？4.如果HashMap的大小超过了负载因子(load factor)定义的容量，怎么办？ 为什么运行下面代码块： HashMap map = new HashMap(); map.put(“语文”, 1); map.put(“数学”, 2); map.put(“英语”, 3); map.put(“历史”, 4); map.put(“政治”, 5); map.put(“地理”, 6); map.put(“生物”, 7); map.put(“化学”, 8); for(Map.Entry entry : map.entrySet()) { System.out.println(entry.getKey() + “: “ + entry.getValue()); } 结果却并非我们想象的那样： 这篇文章就带你去解决这些问题。HashMap最新代码：点击查看 首先解决上面的问题，为什么排序不一致呢？看看源代码的描述。简单翻译最后一句就是：它不确保顺序。不信，你再添加元素看看运行的结果。hashmap中有两个重要的参数，容量(Capacity)和负载因子(Load factor)，容量就是hashmap的大小，负载因子就是填满的比例。再来看我们常用的put函数，添加元素，它的具体代码如下： 610 public V More …put(K key, V value) {611 return putVal(hash(key), key, value, false, true);612 }inal V More …putVal(int hash, K key, V value, boolean onlyIfAbsent,625 boolean evict) {626 Node[] tab; Node p; int n, i;627 if ((tab = table) == null || (n = tab.length) == 0)628 n = (tab = resize()).length;629 if ((p = tab[i = (n - 1) &amp; hash]) == null)630 tab[i] = newNode(hash, key, value, null);631 else {632 Node e; K k;633 if (p.hash == hash &amp;&amp;634 ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))635 e = p;636 else if (p instanceof TreeNode)637 e = ((TreeNode)p).putTreeVal(this, tab, hash, key, value);638 else {639 for (int binCount = 0; ; ++binCount) {640 if ((e = p.next) == null) {641 p.next = newNode(hash, key, value, null);642 if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st643 treeifyBin(tab, hash);644 break;645 }646 if (e.hash == hash &amp;&amp;647 ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))648 break;649 p = e;650 }651 }652 if (e != null) { // existing mapping for key653 V oldValue = e.value;654 if (!onlyIfAbsent || oldValue == null)655 e.value = value;656 afterNodeAccess(e);657 return oldValue;658 }659 }660 ++modCount;661 if (++size &gt; threshold)662 resize();663 afterNodeInsertion(evict);664 return null;665 } 具体流程，可以总结为：对key的hashCode()做hash，然后再计算index;如果没碰撞直接放到bucket里；如果碰撞了，以链表的形式存在buckets后；如果碰撞导致链表过长(大于等于TREEIFY_THRESHOLD)，就把链表转换成红黑树；如果节点已经存在就替换old value(保证key的唯一性)如果bucket满了(超过load factor*current capacity)，就要resize。再看看我们用的get方法： public V More …get(Object key) {555 Node e;556 return (e = getNode(hash(key), key)) == null ? null : e.value;557 }566 final Node More …getNode(int hash, Object key) {567 Node[] tab; Node first, e; int n; K k;568 if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp;569 (first = tab[(n - 1) &amp; hash]) != null) {570 if (first.hash == hash &amp;&amp; // always check first node571 ((k = first.key) == key || (key != null &amp;&amp; key.equals(k))))572 return first;573 if ((e = first.next) != null) {574 if (first instanceof TreeNode)575 return ((TreeNode)first).getTreeNode(hash, key);576 do {577 if (e.hash == hash &amp;&amp;578 ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))579 return e;580 } while ((e = e.next) != null);581 }582 }583 return null;584 }这代码看起来就简单多了，bucket里的第一个节点，直接命中；如果有冲突，则通过key.equals(k)去查找对应的entry若为树，则在树中通过key.equals(k)查找，O(logn)；若为链表，则在链表中通过key.equals(k)查找，O(n)。超过阀值后，我们需要进行扩容，这时就需要调用resize方法，代码如下： final Node[] More …resize() {677 Node[] oldTab = table;678 int oldCap = (oldTab == null) ? 0 : oldTab.length;679 int oldThr = threshold;680 int newCap, newThr = 0;681 if (oldCap &gt; 0) {682 if (oldCap &gt;= MAXIMUM_CAPACITY) {683 threshold = Integer.MAX_VALUE;684 return oldTab;685 }686 else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp;687 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)688 newThr = oldThr &lt;&lt; 1; // double threshold689 }690 else if (oldThr &gt; 0) // initial capacity was placed in threshold691 newCap = oldThr;692 else { // zero initial threshold signifies using defaults693 newCap = DEFAULT_INITIAL_CAPACITY;694 newThr = (int)(DEFAULT_LOAD_FACTOR DEFAULT_INITIAL_CAPACITY);695 }696 if (newThr == 0) {697 float ft = (float)newCap loadFactor;698 newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ?699 (int)ft : Integer.MAX_VALUE);700 }701 threshold = newThr;702 @SuppressWarnings({“rawtypes”,”unchecked”})703 Node[] newTab = (Node[])new Node[newCap];704 table = newTab;705 if (oldTab != null) {706 for (int j = 0; j &lt; oldCap; ++j) {707 Node e;708 if ((e = oldTab[j]) != null) {709 oldTab[j] = null;710 if (e.next == null)711 newTab[e.hash &amp; (newCap - 1)] = e;712 else if (e instanceof TreeNode)713 ((TreeNode)e).split(this, newTab, j, oldCap);714 else { // preserve order715 Node loHead = null, loTail = null;716 Node hiHead = null, hiTail = null;717 Node next;718 do {719 next = e.next;720 if ((e.hash &amp; oldCap) == 0) {721 if (loTail == null)722 loHead = e;723 else724 loTail.next = e;725 loTail = e;726 }727 else {728 if (hiTail == null)729 hiHead = e;730 else731 hiTail.next = e;732 hiTail = e;733 }734 } while ((e = next) != null);735 if (loTail != null) {736 loTail.next = null;737 newTab[j] = loHead;738 }739 if (hiTail != null) {740 hiTail.next = null;741 newTab[j + oldCap] = hiHead;742 }743 }744 }745 }746 }747 return newTab;748 }在resize的过程，简单的说就是把bucket扩充为2倍，之后重新计算index，把节点再放到新的hashmap中。现在我们就可以回答上面的问题了： 什么时候会使用HashMap？他有什么特点？是基于Map接口的实现，存储键值对时，它可以接收null的键值，是非同步的，HashMap存储着Entry(hash, key, value, next)对象。 你知道HashMap的工作原理吗？通过hash的方法，通过put和get存储和获取对象。存储对象时，我们将K/V传给put方法时，它调用hashCode计算hash从而得到bucket位置，进一步存储，HashMap会根据当前bucket的占用情况自动调整容量(超过Load Facotr则resize为原来的2倍)。获取对象时，我们将K传给get，它调用hashCode计算hash从而得到bucket位置，并进一步调用equals()方法确定键值对。如果发生碰撞的时候，Hashmap通过链表将产生碰撞冲突的元素组织起来，在Java 8中，如果一个bucket中碰撞冲突的元素超过某个限制(默认是8)，则使用红黑树来替换链表，从而提高速度。 你知道get和put的原理吗？equals()和hashCode()的都有什么作用？通过对key的hashCode()进行hashing，并计算下标( n-1 &amp; hash)，从而获得buckets的位置。如果产生碰撞，则利用key.equals()方法去链表或树中去查找对应的节点 如果HashMap的大小超过了负载因子(load factor)定义的容量，怎么办？如果超过了负载因子(默认0.75)，则会重新resize一个原来长度两倍的HashMap，并且重新调用hash方法。","tags":[{"name":"java","slug":"java","permalink":"https://koala99.github.io/tags/java/"},{"name":"hashmap","slug":"hashmap","permalink":"https://koala99.github.io/tags/hashmap/"}]},{"title":"布局标签的简单思考","date":"2013-04-11T12:19:42.000Z","path":"2013/04/11/布局标签的简单思考/","text":"一直在用用一些常用的布局标签，include,merge,viewstub，但是否真的了解其原理呢？ 首先我们用的viewstub实际上就是一个懒加载，为什么这么说呢？来看源码： public final class ViewStub extends View { ...... public View inflate() { final ViewParent viewParent = getParent(); // 1 为什么可以直接获取父视图？ // ViewStub的父视图必须是ViewGroup的子类 if (viewParent != null &amp;&amp; viewParent instanceof ViewGroup) { if (mLayoutResource != 0) { // ViewStub必须设置android:layout属性 final ViewGroup parent = (ViewGroup) viewParent; final LayoutInflater factory; if (mInflater != null) { factory = mInflater; } else { factory = LayoutInflater.from(mContext); } // 2 inflate被加载视图 final View view = factory.inflate(mLayoutResource, parent, false); if (mInflatedId != NO_ID) { view.setId(mInflatedId); } // 从父视图中获取当前ViewStub在父视图中的位置 final int index = parent.indexOfChild(this); // 当前ViewStub也是个View仅仅只是用来占位，所以先把占位的ViewStub视图删除 parent.removeViewInLayout(this); // 3 此处获取的是ViewStub上面设置的参数 final ViewGroup.LayoutParams layoutParams = getLayoutParams(); if (layoutParams != null) { parent.addView(view, index, layoutParams); } else { parent.addView(view, index); } // 目的是在复写的setVisibility方法中使用 // 因为ViewStub.setVisibility操作的是被加载视图并非当前ViewStub视图 mInflatedViewRef = new WeakReference&lt;View&gt;(view); // 调用监听 if (mInflateListener != null) { mInflateListener.onInflate(this, view); } // 返回被加载视图，如果不需要当前可以忽略此返回对象 return view; } else { throw new IllegalArgumentException(&quot;ViewStub must have a valid layoutResource&quot;); } } else { throw new IllegalStateException(&quot;ViewStub must have a non-null ViewGroup viewParent&quot;); } } ...... } 可以发现，它构造时： public ViewStub(Context context, AttributeSet attrs, int defStyleAttr, int defStyleRes) { super(context); final TypedArray a = context.obtainStyledAttributes(attrs, R.styleable.ViewStub, defStyleAttr, defStyleRes); mInflatedId = a.getResourceId(R.styleable.ViewStub_inflatedId, NO_ID); mLayoutResource = a.getResourceId(R.styleable.ViewStub_layout, 0); mID = a.getResourceId(R.styleable.ViewStub_id, NO_ID); a.recycle(); setVisibility(GONE); setWillNotDraw(true); } 首选设置需要加载的view为gone，setWillNotDraw为true，继承View.java，代表就是不绘制该布局，而我们一般的view设置为gone时，默认会加入布局绘制的，viewstub它真正绘制就是在调用了inflate()方法时，viewparent就把它加入进来。merge我们也经常用到，它起的作用也很简单，减少层级，看看主要源码: mLayout = new LinearLayout(this); mLayout.setOrientation(LinearLayout.VERTICAL); LayoutInflater.from(this).inflate(R.layout.merge_tag, mLayout); setContentView(mLayout); 另外我们经常会加一个空格空间，经常的做法就是一个没有文字的textview来做，，这样它会参与视图的绘制，实际上我们可以用Space来做，看他的源码可以发现，它的ondraw方法为空，确实很轻量级。","tags":[]},{"title":"http头信息","date":"2012-11-18T08:24:30.000Z","path":"2012/11/18/http头信息/","text":"Accept：告诉WEB服务器自己接受什么介质类型，/ 表示任何类型，type/* 表示该类型下的所有子类型，type/sub-type。 Accept-Charset： 浏览器申明自己接收的字符集Accept-Encoding： 浏览器申明自己接收的编码方法，通常指定压缩方法，是否支持压缩，支持什么压缩方法 （gzip，deflate）Accept-Language：：浏览器申明自己接收的语言语言跟字符集的区别：中文是语言，中文有多种字符集，比如big5，gb2312，gbk等等。 Accept-Ranges：WEB服务器表明自己是否接受获取其某个实体的一部分（比如文件的一部分）的请求。bytes：表示接受，none：表示不接受。 Age：当代理服务器用自己缓存的实体去响应请求时，用该头部表明该实体从产生到现在经过多长时间了。 Authorization：当客户端接收到来自WEB服务器的 WWW-Authenticate 响应时，该头部来回应自己的身份验证信息给WEB服务器。 Cache-Control：请求：no-cache（不要缓存的实体，要求现在从WEB服务器去取）max-age：（只接受 Age 值小于 max-age 值，并且没有过期的对象）max-stale：（可以接受过去的对象，但是过期时间必须小于max-stale 值）min-fresh：（接受其新鲜生命期大于其当前 Age 跟 min-fresh 值之和的缓存对象）响应：public(可以用 Cached 内容回应任何用户)private（只能用缓存内容回应先前请求该内容的那个用户）no-cache（可以缓存，但是只有在跟WEB服务器验证了其有效后，才能返回给客户端）max-age：（本响应包含的对象的过期时间）ALL: no-store（不允许缓存） Connection：请求：close（告诉WEB服务器或者代理服务器，在完成本次请求的响应后，断开连接，不要等待本次连接的后续请求了）。keepalive（告诉WEB服务器或者代理服务器，在完成本次请求的响应后，保持连接，等待本次连接的后续请求）。响应：close（连接已经关闭）。keepalive（连接保持着，在等待本次连接的后续请求）。Keep-Alive：如果浏览器请求保持连接，则该头部表明希望 WEB 服务器保持连接多长时间（秒）。例如：Keep-Alive：300 Content-Encoding：WEB服务器表明自己使用了什么压缩方法（gzip，deflate）压缩响应中的对象。例如：Content-Encoding：gzipContent-Language：WEB 服务器告诉浏览器自己响应的对象的语言。Content-Length： WEB 服务器告诉浏览器自己响应的对象的长度。例如：Content-Length: 26012Content-Range： WEB 服务器表明该响应包含的部分对象为整个对象的哪个部分。例如：Content-Range: bytes 21010-47021/47022Content-Type： WEB 服务器告诉浏览器自己响应的对象的类型。例如：Content-Type：application/xml ETag：就是一个对象（比如URL）的标志值，就一个对象而言，比如一个 html 文件，如果被修改了，其 Etag 也会别修改， 所以，ETag 的作用跟 Last-Modified 的作用差不多，主要供 WEB 服务器 判断一个对象是否改变了。比如前一次请求某个 html 文件时，获得了其 ETag，当这次又请求这个文件时，浏览器就会把先前获得的 ETag 值发送给 WEB 服务器，然后 WEB 服务器会把这个 ETag 跟该文件的当前 ETag 进行对比，然后就知道这个文件有没有改变了。 Expired：WEB服务器表明该实体将在什么时候过期，对于过期了的对象，只有在跟WEB服务器验证了其有效性后，才能用来响应客户请求。是 HTTP/1.0 的头部。例如：Expires：Sat, 23 May 2009 10:02:12 GMT Host：客户端指定自己想访问的WEB服务器的域名/IP 地址和端口号。例如：Host：rss.sina.com.cn If-Match：如果对象的 ETag 没有改变，其实也就意味著对象没有改变，才执行请求的动作。If-None-Match：如果对象的 ETag 改变了，其实也就意味著对象也改变了，才执行请求的动作。 If-Modified-Since：如果请求的对象在该头部指定的时间之后修改了，才执行请求的动作（比如返回对象），否则返回代码304，告诉浏览器该对象没有修改。例如：If-Modified-Since：Thu, 10 Apr 2008 09:14:42 GMTIf-Unmodified-Since：如果请求的对象在该头部指定的时间之后没修改过，才执行请求的动作（比如返回对象）。 If-Range：浏览器告诉 WEB 服务器，如果我请求的对象没有改变，就把我缺少的部分给我，如果对象改变了，就把整个对象给我。 浏览器通过发送请求对象的ETag 或者 自己所知道的最后修改时间给 WEB 服务器，让其判断对象是否改变了。总是跟 Range 头部一起使用。 Last-Modified：WEB 服务器认为对象的最后修改时间，比如文件的最后修改时间，动态页面的最后产生时间等等。例如：Last-Modified：Tue, 06 May 2008 02:42:43 GMT Location：WEB 服务器告诉浏览器，试图访问的对象已经被移到别的位置了，到该头部指定的位置去取。例如：Location： http://i0.sinaimg.cn/dy/deco/2008/0528/sinahome_0803_ws_005_text_0.gif Pramga：主要使用 Pramga: no-cache，相当于 Cache-Control： no-cache。例如：Pragma：no-cache Proxy-Authenticate： 代理服务器响应浏览器，要求其提供代理身份验证信息。Proxy-Authorization：浏览器响应代理服务器的身份验证请求，提供自己的身份信息。 Range：浏览器（比如 Flashget 多线程下载时）告诉 WEB 服务器自己想取对象的哪部分。例如：Range: bytes=1173546- Referer：浏览器向 WEB 服务器表明自己是从哪个 网页/URL 获得/点击 当前请求中的网址/URL。例如：Referer：http://www.sina.com/ Server: WEB 服务器表明自己是什么软件及版本等信息。例如：Server：Apache/2.0.61 (Unix) User-Agent: 浏览器表明自己的身份（是哪种浏览器）。例如：User-Agent：Mozilla/5.0 (Windows; U; Windows NT 5.1; zh-CN;rv:1.8.1.14) Gecko/20080404 Firefox/2.0.0.14 Transfer-Encoding: WEB 服务器表明自己对本响应消息体（不是消息体里面的对象）作了怎样的编码，比如是否分块（chunked）。例如：Transfer-Encoding: chunked Vary: WEB服务器用该头部的内容告诉 Cache 服务器，在什么条件下才能用本响应所返回的对象响应后续的请求。假如源WEB服务器在接到第一个请求消息时，其响应消息的头部为：Content-Encoding: gzip; Vary: Content-Encoding 那么 Cache 服务器会分析后续请求消息的头部，检查其 Accept-Encoding，是否跟先前响应的 Vary 头部值一致，即是否使用相同的内容编码方法，这样就可以防止 Cache 服务器用自己Cache 里面压缩后的实体响应给不具备解压能力的浏览器。例如：Vary：Accept-Encoding Via： 列出从客户端到 OCS 或者相反方向的响应经过了哪些代理服务器，他们用什么协议（和版本）发送的请求。当客户端请求到达第一个代理服务器时，该服务器会在自己发出的请求里面添加 Via 头部，并填上自己的相关信息，当下一个代理服务器 收到第一个代理服务器的请求时，会在自己发出的请求里面复制前一个代理服务器的请求的Via头部，并把自己的相关信息加到后面， 以此类推，当 OCS 收到最后一个代理服务器的请求时，检查 Via 头部，就知道该请求所经过的路由。例如：Via：1.0 236-81.D07071953.sina.com.cn:80 (squid/2.6.STABLE13)","tags":[{"name":"java","slug":"java","permalink":"https://koala99.github.io/tags/java/"},{"name":"http","slug":"http","permalink":"https://koala99.github.io/tags/http/"}]},{"title":"bindservice与startservice的区别","date":"2012-10-18T08:24:30.000Z","path":"2012/10/18/bindservice与startservice的区别/","text":"1、生命周期上的区别执行startService时，Service会经历onCreate-&gt;onStartCommand。当执行stopService时，直接调用onDestroy方法。调用者如果没有stopService，Service会一直在后台运行，下次调用者再起来仍然可以stopService。 执行bindService时，Service会经历onCreate-&gt;onBind。这个时候调用者和Service绑定在一起。调用者调用unbindService方法或者调用者Context不存在了（如Activity被finish了），Service就会调用onUnbind-&gt;onDestroy。这里所谓的绑定在一起就是说两者共存亡了。 多次调用startService，该Service只能被创建一次，即该Service的onCreate方法只会被调用一次。但是每次调用startService，onStartCommand方法都会被调用。Service的onStart方法在API 5时被废弃，替代它的是onStartCommand方法。 第一次执行bindService时，onCreate和onBind方法会被调用，但是多次执行bindService时，onCreate和onBind方法并不会被多次调用，即并不会多次创建服务和绑定服务。","tags":[{"name":"service","slug":"service","permalink":"https://koala99.github.io/tags/service/"},{"name":"android","slug":"android","permalink":"https://koala99.github.io/tags/android/"}]},{"title":"activity的一些生命周期场景","date":"2012-09-11T12:37:35.000Z","path":"2012/09/11/activity的一些生命周期场景/","text":"1，进入Activity onCreate -&gt; onStart -&gt; onResume2，BACK键 onPause -&gt; onStop -&gt; onDestroy3，HOME键 Home键退出：onPause -&gt; onStop Home键回来：onRestart -&gt; onStart -&gt; onResume4，休眠/恢复 休眠：onPause 恢复：onResume5，旋转屏幕 未设置android:configChanges： onPause -&gt; onStop -&gt; onDestory -&gt; onCreate -&gt; onStart -&gt; onResume设置了android:configChanges=”orientation| keyboardHidden”：不会触发生命周期方法.6，来电 来电，显示来电界面：onPause -&gt; onStop 关闭电话界面，重新回到当前Activity：onRestart -&gt; onStart -&gt; onResume 7,其他Activity 进入下一个Activity： A.onPause -&gt; B.onCreate -&gt; B.onStart -&gt;B.onResume -&gt; A.onStop 从其他Activity返回至当前Acitivity： onRestart -&gt; onStart -&gt; onResume 与Activity生命周期结合的应用场景3.1 与广播(Broadcast)结合 在onResume注册广播(registerLinstener)，在onPause注销广播(unregisterLinstener)。 例如： 做”摇一摇”功能（传感器）、监听网络变化，就可以在onResume中注册监听，在onPause里注销掉，已节省资源提高效率。 3.2与服务(Service)结合 在onStart绑定服务(bindService)，在onStop中取消绑定(unbindService)。 例如： 需要通过Service定时更新UI上的数据，而Activity的可见周期在onStart与onStop之间，那么就可以再onStart时启动服务，在onStop时停止服务。为了节约系统资源，除了提高用户体验以外，开发人员应尽可能的优化程序。 3.3 与Cursor结合 使用managedQuery让Activity帮你管理Cursor的生命周期，不用自己去close。 3.4 释放资源 可以在onDestory中释放一些资源。比如可以在onDestory时调用MediaPlayer的release。","tags":[]}]