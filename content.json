[{"title":"ffmpeg使用中的记录","date":"2017-09-30T06:27:00.000Z","path":"2017/09/30/ffmpeg使用中的记录/","text":"新版本的ffmepg中，音视频的解码，编码都共用同一套了，一个很简单的例子: avcodec_send_packet(pCodecCtx, packet); ret = avcodec_receive_frame(pCodecCtx, pFrame);解码时，先接受到packet，再来获取frame。 avcodec_send_frame avcodec_receive_packet 这两个就是配套来进行编码。 这边有自己以前写的ffmepg的一些应用，比如结合qt做一个播放器，https://github.com/koala99/FFmpegTest/tree/master 还有自己在使用提供的ffplay工具来测试mp4解码分离的yuv 和 pcm时，sample_fmt 对应出来的是 fltp这个格式，所以播放的命令应该就是: ffplay -ar 48000 -channel_layout 4 -channels 1 -f f32le -i audio.pcm 说实话，ffmpeg的门槛算是稍微高的，关键资料少，网上大多简单的都是命令来解决问题。所以，不得不耗费经历，自己来解决问题。","tags":[{"name":"音视频","slug":"音视频","permalink":"https://koala99.github.io/tags/音视频/"}]},{"title":"mac下 clion配置qt的开发环境","date":"2017-09-26T12:57:40.000Z","path":"2017/09/26/mac下-clion配置qt的开发环境/","text":"之前玩qt，都是用自带的 qtCreator 这个编辑器，然后编译项目都是内置的qmake。这段时间，正好在做ffmpeg移植到android去，发现网上有不少关于qt+ffmpeg+opencv的结合，所以自己也把IDE改为了 clion。当然，改过来问题多多，首先项目编译器都是cmake了，然后引入各种库，这里简单做下配置，ffmpeg和qt这边都是通过 homebrew来直接安装的，对应的include路径都在： /usr/local/Cellar/ffmpeg/3.4.1/include/ /usr/local/Cellar/sdl2/2.0.7/include /usr/local/opt/qt/includelib都在： usr/local/Cellar/ffmpeg/3.4.1/lib/ , /usr/local/Cellar/sdl2/2.0.7/lib , /usr/local/opt/qt/lib 遇到的问题主要就是在编写cmakelists里面的配置， 这边贴下自己的代码： cmake_minimum_required(VERSION 3.9)project(QtFFmpeg)set(CMAKE_CXX_FLAGS “${CMAKE_CXX_FLAGS} -std=c++11”)include_directories(/usr/local/Cellar/ffmpeg/3.4.1/include/ ,/usr/local/Cellar/sdl2/2.0.7/include , /usr/local/opt/qt/include)link_directories(/usr/local/Cellar/ffmpeg/3.4.1/lib/ , /usr/local/Cellar/sdl2/2.0.7/lib , /usr/local/opt/qt/lib)set(CMAKE_CXX_STANDARD 11)set(CMAKE_PREFIX_PATH “/usr/local/Cellar/qt/5.10.0”) find_package(Qt5Core REQUIRED)find_package(Qt5Widgets REQUIRED) set(CMAKE_INCLUDE_CURRENT_DIR ON)set(CMAKE_AUTOMOC ON) set(CMAKE_AUTOUIC ON) # .ui filesset(CMAKE_AUTORCC ON)qt5_wrap_ui(ui_FILES mainwindow.ui)set(SOURCE_FILES main.cpp mainwindow.cpp mainwindow.h ${ui_FILES})add_executable(QtFFmpeg main.cpp)target_link_libraries( QtFFmpeg avcodec avdevice avfilter avformat avresample avutil postproc swresample swscale SDL2 Qt5::Widgets Qt5::Core Qt5::Gui 其中set(CMAKEPREFIXPATH “/usr/local/Cellar/qt/5.10.0”)， 这个是设置本地编译的cmake，必须是对应的qt里面的如果我们用到了ui文件，必须使用 qt5wrapui这边先简单记录下，等后续工程完了，打算传到github上去","tags":[{"name":"qt","slug":"qt","permalink":"https://koala99.github.io/tags/qt/"},{"name":"clion","slug":"clion","permalink":"https://koala99.github.io/tags/clion/"},{"name":"cmake","slug":"cmake","permalink":"https://koala99.github.io/tags/cmake/"}]},{"title":"ubuntu 16.04下drupal的安装与配置 ","date":"2017-08-24T11:16:48.000Z","path":"2017/08/24/ubuntu-16-04下drupal的安装与配置/","text":"准备工作 下载 Drupal 7：到 Drupal 项目页面下载 drupal 程序包，项目地址: http://drupal.org/project/drupal解压 Drupal 7：将下载下来 drupal 程序包进行解压缩，得到名为 drupal-版本号 的目录，为目录改名，如改成 drupal7下载语言包文件：到 http://localize.drupal.org/translate/languages/zh-hans (link is external) 页面下载对应版本的语言包（.po文件）安装语言包文件：将 .po 文件放置到 drupal7/profiles/standard/translations 目录下上传：将 drupal7 目录下的所有内容放置/上传到网站根目录创建配置文件：进入 sites/default 目录，将 default.settings.php 复制一份，命名为 settings.php创建用户文件目录：在 sites/default 目录下新建一个目录，名为 files设置权限：如果是Linux平台，请将 files 目录的权限设置为 777，settings.php 设置为web服务器用户可写，如果不清楚，也可先设置为777Drupal 7 中文安装教程 安装页面：执行完准备工作之后，便可通过浏览器访问drupal网站地址即可看到安装界面，默认选中“Standard”，点击 Save and continue 执行下一步选择语言：如果执行了准备工作中的第3,4步，则此页面会出现语言选择项，选中 Chinese,Simplified（简体中文），点击 Save and continue 执行下一步Drupal 7 需要 php dom 扩展，如果没有安装 dom 扩展则会出现错误，为PHP安装dom扩展后，重启web服务器即可；如果没有完成准备工作中的第4,5,6步，也会出现错误提示，执行完准备工作中的第4,5,6步，错误消息就会消失数据库配置：填写数据库的配置配置信息，包括数据库名、数据库用户名 和 数据库用户密码，填好之后点击下一步，开始安装Drupal安装Drupal：这一步中系统执行Drupal的安装工作，然后进入Drupal站点配置页面 导入翻译：这一步也由系统自动执行修正配置文件权限：如果是Linux平台，执行完此步操作之后，请将 sites/default/settings.php 文件权限改为只读(444)站点设置：在站点设置页面，填写网站名称、网站邮箱、超级管理员帐号、超级管理员邮箱、超级管理员密码、默认时区和简洁链接，配置完成之后，点击”Save and Continue”即完成了 Drupal 的安装。完成Drupal的安装，进入完成信息提示页面，点击”访问你的新网站”链接即可访问你的Drupal站点 :D 里面涉及到修改apache的东西:apache2.4配置根目录文件在/etc/apache2/sites-available/000-default.conf默认是 var/www/html可以改成想要的目录，比如/home/judge/etc/web 默认主页的配置在/etc/apache2/mods-available/dir.conf可以为如下格式：index.html index.cgi index.pl index.php index.xhtml index.htm可以修改为 *.html等 在/etc/apache2目录下，打开apache2.conf文件，加一句：ServerName localhost:80 还是apache2.conf文件，找到 Options FollowSymLinks AllowOverride None Order deny,allow allow from all #Require all denied 把Require all denied这一句注释掉，加上 allow from all","tags":[]},{"title":"cuda的通信模型","date":"2017-03-03T05:53:53.000Z","path":"2017/03/03/cuda的通信模型/","text":"最近自己的深度学习工作站已经搭起。开始学习cuda。 udacity上课程 cs344cuda根据不同的memory映射方式，我们将task分为以下几种类型：Map, Gather, Scatter, Stencil, transpose. Map: one input - one outputGather: several input - one outpute.g image blur by averageScatter: one input - several outpute.g add a value to its neighbors(因为每个thread 将结果scatter到各个memory，所以叫scatter)stencil: 对input中的每一个位置，stencil input：该点的neighborhood stencil output：该点value e.g image blur by average 这样也可以看出，stencil和gather很像，其实stencil是gather的一种，只不过stencil要求input必须是neighborhood而且对input的每一个元素都要操作 transposeinput：matrix Moutput: M^T","tags":[{"name":"并行计算","slug":"并行计算","permalink":"https://koala99.github.io/tags/并行计算/"},{"name":"cuda","slug":"cuda","permalink":"https://koala99.github.io/tags/cuda/"}]},{"title":"ios 开发小结","date":"2016-09-20T13:54:34.000Z","path":"2016/09/20/ios-开发小结/","text":"很早就接触swift了，之前虽然写过一些简单的demo，但还没系统性完成一个商业app。之前开发完了公司的安卓版产品，没有ios，自己就承担开发ios的版本，算下来，时间比安卓开发稍微长一点，考虑到swift 3版本升级，造成一些库的兼容处理，总体时间上跟安卓开发时间差不多。这里就介绍一些自己用到的一些库。首先是布局方面，ios开发的布局，自己真的很不喜欢，虽然提供了storyboard这样的可视化拖拉，这边自己都是做autolayout,使用的库是Snapkit,自己通过纯代码来实现布局。虽然代码量大，但是写起来比较熟。网络请求之前用原生的来写，做json解析，真的挺麻烦的，后来采用了SwiftHTTP,使用简单。返回数据这边都做了序列化操作，ios中这边采用了ObjectMapper，它来做实体类的序列化，挺方便的。考虑到我们安卓中常常用到的事务总栈eventbus，swift方面也有对应的实现，基于notification来做的封装。 SwiftEventBus 。使用方法也与eventbus类似。一些图像的异步加载，离线缓存，我这边采用的是功能强大的 HanekeSwift ,它的作用远远不止这些。总体而言，因为app上没有涉及太多的复杂功能点，开发起来很顺利，ios的开发架构也跟安卓一致，最大的变数就是swift这本语言，2.0到3.0变化还有有些大的，当然，coder必须适应这些变化，不断学习。","tags":[{"name":"ios","slug":"ios","permalink":"https://koala99.github.io/tags/ios/"},{"name":"swift","slug":"swift","permalink":"https://koala99.github.io/tags/swift/"}]},{"title":"swift 3.0之后的一些变化","date":"2016-09-11T13:47:32.000Z","path":"2016/09/11/swift-3-0之后的一些变化/","text":"由于之前项目都是swift2写的，现在都得做升级，更新到swift3，这边就做下记录。 CGPointMake -> CGPoint let point = CGPoint(x: 0,y :0) // x和y的值可以是CGFloat, Double, Int CGSizeMake -> CGSize let size = CGSize(width: 100, height: 100) // width和height的值可以是CGFloat, Double, Int CGRectMake -> CGRect 用CGPoint和CGSize来构建 let rect = CGRect(origin: CGPoint(x: 0,y :0), size: CGSize(width: 100, height: 100)) 用CGFloat，Double和Int值构建 let rect = CGRect(x: 0, y: 0, width: 100, height: 100) // 参数类型可以为CGFloat, Double, Int CGRectZero->CGRect.zero & CGPointZero -> CGPoint.zero let size = CGSize.zero // width = 0, height = 0 let point = CGPoint.zero // x = 0, y = 0，等同于CGPointZero let rect = CGRect.zero // 等同与 CGRectZero","tags":[{"name":"ios,swift","slug":"ios-swift","permalink":"https://koala99.github.io/tags/ios-swift/"}]},{"title":"cmake配置","date":"2016-05-20T07:52:53.000Z","path":"2016/05/20/cmake配置/","text":"之前在mac上，开发c++，一向都是用qt creator，现在在ubuntu上开发，做opencv相关的学习，自己也把qmake改成强大的cmake了，结果发现一直找不到c的编译器，很是奇怪（系统由14.04升级到16.04）： No CMAKE_C_COMPILER could be found 终端里面命令： which gcc 也能找到路径。 最终没辙，只得在环境变量中定义才解决。至于为啥会造成找不到gcc路径，目前还不清楚，先记录下这个问题。","tags":[{"name":"日常记录","slug":"日常记录","permalink":"https://koala99.github.io/tags/日常记录/"},{"name":"ubuntu","slug":"ubuntu","permalink":"https://koala99.github.io/tags/ubuntu/"}]},{"title":"opencv的安装和配置","date":"2016-05-17T13:15:30.000Z","path":"2016/05/17/opencv的安装和配置/","text":"opencv是计算机视觉处理必备，自己趁这段时间工作不是很繁忙，也开始学习下。1 预先安装一些软件： sudo apt-get install build-essential cmake libgtk2.0-dev pkg-config python-dev python-numpy libavcodec-dev libavformat-dev libswscale-dev2 去管网下载opencv压缩包 3 解压压缩包到某文件夹（用windows习惯了，直接右键提取到此处。。。） 4 command中cd到该解压缩的文件夹中，然后创建build文件夹 mkdir build 5 进入build目录 cd build 6 编译opencv源码 cmake -D CMAKE_BUILD_TYPE=RELEASE -D CMAKE_INSTALL_PREFIX=/usr/local .. 7 安装 sudo make install 自己环境配置是ubuntu+qt+opencv， opencv直接官网下载，源码编译安装，这部分就不用介绍了，值得注意的是，在qt creator中引用libs库时，需在.pro文件中做如下配置： INCLUDEPATH += /usr/local/include\\ /usr/local/include/opencv\\ /usr/local/include/opencv2LIBS += -L/usr/local/lib -lopencv_core -lopencv_imgcodecs -lopencv_highgui TEMPLATE = appCONFIG += console c++11CONFIG -= app_bundleCONFIG -= qt SOURCES += main.cpp环境配置好了，后面继续学习。","tags":[{"name":"opencv ubuntu","slug":"opencv-ubuntu","permalink":"https://koala99.github.io/tags/opencv-ubuntu/"}]},{"title":"机器学习入门系列_knn","date":"2015-04-11T12:56:00.000Z","path":"2015/04/11/knn算法和应用/","text":"knn也就是K最近邻算法，采用测量不同特征值之间的距离方法进行分类，具体操作流程也就分以下几步： 1:计算已知类别数据集中的点与当前点的距离 2：按照距离递增排序 3：选取与当前距离最小的k个点 4：确认前k个点所在类别的出现频率 5：返回前k个点出现频率最高的类别作为当前点的预测分类 书上第一张也给出了一个简单的knn测试,里面引用了numpy库,源码如下: from numpy import *import operatorfrom os import listdirdef classify0(inX, dataSet, labels, k): # 计算距离 #获取dataSet的长度 dataSetSize = dataSet.shape[0] #生成新的矩阵，减去存在的矩阵 diffMat = tile(inX, (dataSetSize,1)) - dataSet #矩阵元素平方 sqDiffMat = diffMat**2 #axis=1 行相加， axis=0 列相加 sqDistances = sqDiffMat.sum(axis=1) #开方 distances = sqDistances**0.5 #函数是将x中的元素从小到大排列，提取其对应的index(索引) sortedDistIndicies = distances.argsort() print(sortedDistIndicies) #选择距离最小的k个点 classCount={} for i in range(k): print(sortedDistIndicies[i]) voteIlabel = labels[sortedDistIndicies[i]] print(voteIlabel) classCount[voteIlabel] = classCount.get(voteIlabel,0) + 1 print(classCount) #排序 sortedClassCount = sorted(classCount.iteritems(), key=operator.itemgetter(1), reverse=True) print(sortedClassCount) return sortedClassCount[0][0] def createDataSet(): group = array([[1.0,1.1],[1.0,1.0],[0,0],[0,0.1]]) labels = [‘A’,’A’,’B’,’C’] return group, labelsif name == “main“: data = createDataSet() print(classify0([0,0],data[0],data[1],3))","tags":[{"name":"机器学习","slug":"机器学习","permalink":"https://koala99.github.io/tags/机器学习/"}]},{"title":"机器学习入门系列_准备篇","date":"2015-04-10T11:52:53.000Z","path":"2015/04/10/机器学习初学/","text":"现在公司的一个留美回来的博士就是美国那边做机器学习方面的工作，当时感觉还挺有意思的，觉得机器学习也很有前途的，于是还买了一本图解学习的书看了下，奈何里面都是公式的推导，看的懵逼懵逼的。 可能我擅长实践但是缺乏理论，于是乎，趁最近工作不是很繁忙，自己重新捡回来了大学的高数，概率论和线性代数。 首先记录下机器学习的一些数学基本知识。 高数：常见函数求导导数运算法则复合函数求导方向导数与梯度（难点）凸集与凸函数一元函数求极值多元函数求极值（了解）拉格朗日乘子法泰勒公式展开空间解析几何和向量代数 线性代数 线性代数：矩阵的定义，矩阵的转置单位矩阵，三角矩阵，对称矩阵向量内积，相关性正交向量组，标准正交基，正交矩阵特征值分解 概率论事件的关系与运算：条件概率，全概率公式，贝叶斯公式随机变量的期望，方差协方差，相关系数，协方差矩阵概率分布：0-1分布，二项分布，高斯分布极大似然函数估计大数定律，伯努利大数定律，中心极限定理 这次，自己又买了一本machine learning in action的书籍，从它开始一步一步学习。","tags":[{"name":"机器学习","slug":"机器学习","permalink":"https://koala99.github.io/tags/机器学习/"}]},{"title":"NumPy常用的函数库","date":"2015-03-05T02:15:01.000Z","path":"2015/03/05/NumPy常用的函数库/","text":"创建二维数组 array()：array = ones(5)array = [1,1,1,1,1]array = empty(5)使用ones可以创建任意维度和元素个数的数组，其元素均为1。zeros（） 全是0 的矩阵，empty函数的使用方法一样，只是它创建的是数组所有元素均为空，所以它是速度最快的创建数组的方法。set = array([[1., 2, ],[3., 4.],[5., 6.],[7., 9.]]) 求数组的 行数： set.shape[0] 4求数组的列数：set.shape[1] 2求数组的大小 set.shape(4, 2)求数组的类型 set.dtypedtype(‘float64’) numpy.eye(N,M=None, k=0, dtype=) 关注第一个第三个参数就行了 第一个参数：输出方阵（行数=列数）的规模，即行数或列数 第三个参数：默认情况下输出的是对角线全“1”，其余全“0”的方阵，如果k为正整数，则在右上方第k条对角线全“1”其余全“0”，k为负整数则在左下方第k条对角线全“1”其余全“0”。 创建矩阵 identity() tile(1,2)： array([1, 1]) tile((1,2,3),3)： array([1, 2, 3, 1, 2, 3, 1, 2, 3]) b=[1,3,5] tile(b,[2,3])： array([[1, 3, 5, 1, 3, 5, 1, 3, 5], [1, 3, 5, 1, 3, 5, 1, 3, 5]]) c = np.array([[0, 2, 1], [3, 5, 6], [0, 1, 1]]) print c.sum()print c.sum(axis=0)print c.sum(axis=1) 结果分别是：19, [3 8 8], [ 3 14 2] 函数是将x中的元素从小到大排列，提取其对应的index(索引)array.argsort() Out[4]: array([3, 2, 0, 1]) x = np.array([[0, 3], [2, 2]])： array([[0, 3], [2, 2]]) np.argsort(x, axis=0) #按列排序 array([[0, 1], [1, 0]]) np.argsort(x, axis=1) #按行排序 array([[0, 1], [0, 1]])","tags":[{"name":"机器学习","slug":"机器学习","permalink":"https://koala99.github.io/tags/机器学习/"},{"name":"numpy","slug":"numpy","permalink":"https://koala99.github.io/tags/numpy/"}]},{"title":"android架构浅谈","date":"2014-11-13T13:30:20.000Z","path":"2014/11/13/android架构浅谈/","text":"从做安卓开始，心中最熟悉的还是mvc这中架构，上大学那会，自己写最初写java web那会，就是构造java bean，jsp做展现，servlet做控制器，慢慢到后来，随着用到ssh这些框架，分层也越来越细了。写了两年多的安卓，基本还是沿用mvc框架来处理问题。今年开始流行起来mvp这个框架了，这个框架最初还是在微软.net平台上实践，慢慢有人就开始用到安卓上来了。为什么要用mvp？肯定还是android上mvc不够好，首先我们来看这个模型图：明显可以注意到 这三层形成了一个回路，耦合度高。看看android上mvc的实现，View层：定义View或ViewGroup或xml，负责将用户的请求通知Controller，并根据model更新界面；Controller层：我们的activity或者fragment这个根据model更改界面；model：最常见的java bean和网络回传的数据看似划分的很清楚，其实问题就出在activity或fragment上，他们里面也有大量处理ui的代码，页面操作也在这里面，从而造成耦合度过高，一个很简单的例子，我们定义了很多button，每个button的的动作监听需要在activity中，监听后改变ui也在activity中，一旦控件过多，activity就很膨胀。于是我们就开始引出mvp了，他实际上是mvc的改造，看图说话：最大的区别就是model与view完全解绑了，不会打交道了。view就是我们那些xml，activity，presenter处理具体业务model不变。这里可能出问题的就是presenter对activity或fragment的引用，一般采用弱引用来解决这个问题。总结下它们的处理流程:在MVC中，用户的请求首先会到达Controller,有Controller从Model获取数据，选择合适的View,把处理结果呈现到View上；在MVP中，用户的请求首先会到达View,View传递请求到特定的Presenter,Presenter从Model获取数据后，再把处理结果通过接口传递到View。","tags":[]},{"title":"reentrantlock与synchronized对比","date":"2014-10-16T10:24:30.000Z","path":"2014/10/16/reentrantlock与synchronized对比/","text":"锁作为并发共享数据，保证一致性的工具，在JAVA平台有多种实现，我们常用的就是synchronized 和 ReentrantLock。相同点，他们都属于可重入锁，可重入锁，也叫做递归锁，指的是同一线程 外层函数获得锁之后 ，内层递归函数仍然有获取该锁的代码，但不受影响。可以看下面简单的例子： public class Test implements Runnable{ public synchronized void get(){ System.out.println(Thread.currentThread().getId()); set(); } public synchronized void set(){ System.out.println(Thread.currentThread().getId()); } @Override public void run() { get(); } public static void main(String[] args) { Test ss=new Test(); new Thread(ss).start(); new Thread(ss).start(); new Thread(ss).start(); }} public class Test implements Runnable { ReentrantLock lock = new ReentrantLock(); public void get() { lock.lock(); System.out.println(Thread.currentThread().getId()); set(); lock.unlock(); } public void set() { lock.lock(); System.out.println(Thread.currentThread().getId()); lock.unlock(); } @Override public void run() { get(); } public static void main(String[] args) { Test ss = new Test(); new Thread(ss).start(); new Thread(ss).start(); new Thread(ss).start(); }}两个例子最后的结果都是正确的，即 同一个线程id被连续输出两次。可重入锁最大的作用是避免死锁. 1、ReentrantLock 拥有Synchronized相同的并发性和内存语义，此外还多了 锁投票，定时锁等候和中断锁等候线程A和B都要获取对象O的锁定，假设A获取了对象O锁，B将等待A释放对O的锁定，如果使用 synchronized ，如果A不释放，B将一直等下去，不能被中断如果 使用ReentrantLock，如果A不释放，可以使B在等待了足够长的时间以后，中断等待，而干别的事情 ReentrantLock获取锁定与三种方式：a) lock(), 如果获取了锁立即返回，如果别的线程持有锁，当前线程则一直处于休眠状态，直到获取锁b) tryLock(), 如果获取了锁立即返回true，如果别的线程正持有锁，立即返回false；c)tryLock(long timeout,TimeUnit unit)， 如果获取了锁定立即返回true，如果别的线程正持有锁，会等待参数给定的时间，在等待的过程中，如果获取了锁定，就返回true，如果等待超时，返回false；d) lockInterruptibly:如果获取了锁定立即返回，如果没有获取锁定，当前线程处于休眠状态，直到或者锁定，或者当前线程被别的线程中断 2、synchronized是在JVM层面上实现的，不但可以通过一些监控工具监控synchronized的锁定，而且在代码执行时出现异常，JVM会自动释放锁定，但是使用Lock则不行，lock是通过代码实现的，要保证锁定一定会被释放，就必须将unLock()放到finally{}中 3、在资源竞争不是很激烈的情况下，Synchronized的性能要优于ReetrantLock，但是在资源竞争很激烈的情况下，Synchronized的性能会下降几十倍，但是ReetrantLock的性能能维持常态； 5.0的多线程任务包对于同步的性能方面有了很大的改进，在原有synchronized关键字的基础上，又增加了ReentrantLock，以及各种Atomic类。了解其性能的优劣程度，有助与我们在特定的情形下做出正确的选择。 总体的结论先摆出来： synchronized：在资源竞争不是很激烈的情况下，偶尔会有同步的情形下，synchronized是很合适的。原因在于，编译程序通常会尽可能的进行优化synchronize，另外可读性非常好，不管用没用过5.0多线程包的程序员都能理解。 ReentrantLock:ReentrantLock提供了多样化的同步，比如有时间限制的同步，可以被Interrupt的同步（synchronized的同步是不能Interrupt的）等。在资源竞争不激烈的情形下，性能稍微比synchronized差点点。但是当同步非常激烈的时候，synchronized的性能一下子能下降好几十倍。而ReentrantLock确还能维持常态。","tags":[{"name":"java","slug":"java","permalink":"https://koala99.github.io/tags/java/"},{"name":"多线程","slug":"多线程","permalink":"https://koala99.github.io/tags/多线程/"}]},{"title":"java多线程详解","date":"2014-10-15T08:24:30.000Z","path":"2014/10/15/java多线程详解/","text":"公司的背单词软件，大量用到多线程技术。这边就自己做个总结。首先我们要清楚线程的概念，别让它与进程搞混淆。 进程：每个进程都有独立的代码和数据空间（进程上下文），进程间的切换会有较大的开销，一个进程包含1–n个线程。（进程是资源分配的最小单位） 线程：同一类线程共享代码和数据空间，每个线程有独立的运行栈和程序计数器(PC)，线程切换开销小。（线程是cpu调度的最小单位） 线程的五种状态：创建，就绪，运行，阻塞，终止 在java中要想实现多线程，有三种手段，一种是继续Thread类，另外一种是实现Runable接口.还有一种是实现Callable接口，并与Future、线程池结合使用。Thread和Runnable的区别如果一个类继承Thread，则不适合资源共享。但是如果实现了Runable接口的话，则很容易的实现资源共享。总结：实现Runnable接口比继承Thread类所具有的优势： 1）：适合多个相同的程序代码的线程去处理同一个资源 2）：可以避免java中的单继承的限制 3）：增加程序的健壮性，代码可以被多个线程共享，代码和数据独立 4）：线程池只能放入实现Runable或callable类线程，不能直接放入继承Thread的类一些常用的方法：①sleep(long millis): 在指定的毫秒数内让当前正在执行的线程休眠（暂停执行）②join():指等待t线程终止。③yield():暂停当前正在执行的线程对象，并执行其他线程。sleep()和yield()的区别):sleep()使当前线程进入停滞状态，所以执行sleep()的线程在指定的时间内肯定不会被执行；yield()只是使当前线程重新回到可执行状态，所以执行yield()的线程有可能在进入到可执行状态后马上又被执行。④setPriority(): 更改线程的优先级。⑤interrupt():不要以为它是中断某个线程！它只是线线程发送一个中断信号，让线程在无限等待时（如死锁时）能抛出抛出，从而结束线程，但是如果你吃掉了这个异常，那么这个线程还是不会中断的！wait和sleep区别共同点： 他们都是在多线程的环境下，都可以在程序的调用处阻塞指定的毫秒数，并返回。 wait()和sleep()都可以通过interrupt()方法 打断线程的暂停状态 ，从而使线程立刻抛出InterruptedException。如果线程A希望立即结束线程B，则可以对线程B对应的Thread实例调用interrupt方法。如果此刻线程B正在wait/sleep /join，则线程B会立刻抛出InterruptedException，在catch() {} 中直接return即可安全地结束线程。需要注意的是，InterruptedException是线程自己从内部抛出的，并不是interrupt()方法抛出的。对某一线程调用 interrupt()时，如果该线程正在执行普通的代码，那么该线程根本就不会抛出InterruptedException。但是，一旦该线程进入到 wait()/sleep()/join()后，就会立刻抛出InterruptedException 。不同点： Thread类的方法：sleep(),yield()等Object的方法：wait()和notify()等 每个对象都有一个锁来控制同步访问。Synchronized关键字可以和对象的锁交互，来实现线程的同步。sleep方法没有释放锁，而wait方法释放了锁，使得其他线程可以使用同步控制块或者方法。 wait，notify和notifyAll只能在同步控制方法或者同步控制块里面使用，而sleep可以在任何地方使用 sleep必须捕获异常，而wait，notify和notifyAll不需要捕获异常所以sleep()和wait()方法的最大区别是：sleep()睡眠时，保持对象锁，仍然占有该锁；而wait()睡眠时，释放对象锁。但是wait()和sleep()都可以通过interrupt()方法打断线程的暂停状态，从而使线程立刻抛出InterruptedException（但不建议使用该方法）。sleep（）方法sleep()使当前线程进入停滞状态（阻塞当前线程），让出CUP的使用、目的是不让当前线程独自霸占该进程所获的CPU资源，以留一定时间给其他线程执行的机会; sleep()是Thread类的Static(静态)的方法；因此他不能改变对象的机锁，所以当在一个Synchronized块中调用Sleep()方法是，线程虽然休眠了，但是对象的机锁并木有被释放，其他线程无法访问这个对象（即使睡着也持有对象锁）。 在sleep()休眠时间期满后，该线程不一定会立即执行，这是因为其它线程可能正在运行而且没有被调度为放弃执行，除非此线程具有更高的优先级。wait（）方法wait()方法是Object类里的方法；当一个线程执行到wait()方法时，它就进入到一个和该对象相关的等待池中，同时失去（释放）了对象的机锁（暂时失去机锁，wait(long timeout)超时时间到后还需要返还对象锁）；其他线程可以访问； wait()使用notify或者notifyAlll或者指定睡眠时间来唤醒当前等待池中的线程。 wiat()必须放在synchronized block中，否则会在program runtime时扔出”java.lang.IllegalMonitorStateException“异常。线程同步1、synchronized关键字的作用域有二种：1）是某个对象实例内，synchronized aMethod(){}可以防止多个线程同时访问这个对象的synchronized方法（如果一个对象有多个synchronized方法，只要一个线程访问了其中的一个synchronized方法，其它线程不能同时访问这个对象中任何一个synchronized方法）。这时，不同的对象实例的synchronized方法是不相干扰的。也就是说，其它线程照样可以同时访问相同类的另一个对象实例中的synchronized方法； 2）是某个类的范围，synchronized static aStaticMethod{}防止多个线程同时访问这个类中的synchronized static 方法。它可以对类的所有对象实例起作用。 2、除了方法前用synchronized关键字，synchronized关键字还可以用于方法中的某个区块中，表示只对这个区块的资源实行互斥访问。用法是: synchronized(this){/区块/}，它的作用域是当前对象； 3、synchronized关键字是不能继承的，也就是说，基类的方法synchronized f(){} 在继承类中并不自动是synchronized f(){}，而是变成了f(){}。继承类需要你显式的指定它的某个方法为synchronized方法；synchronized关键字不能继承。一个线程访问一个对象的synchronized代码块时，别的线程可以访问该对象的非synchronized代码块而不受阻塞。无论synchronized关键字加在方法上还是对象上，如果它作用的对象是非静态的，则它取得的锁是对象；如果synchronized作用的对象是一个静态方法或一个类，则它取得的锁是对类，该类所有的对象同一把锁。每个对象只有一个锁（lock）与之相关联，谁拿到这个锁谁就可以运行它所控制的那段代码。实现同步是要很大的系统开销作为代价的，甚至可能造成死锁，所以尽量避免无谓的同步控制。Java语言提供了一种稍弱的同步机制，即volatile变量，用来确保将变量的更新操作通知到其他线程。当把变量声明为volatile类型后，编译器与运行时都会注意到这个变量是共享的，因此不会将该变量上的操作与其他内存操作一起重排序。volatile变量不会被缓存在寄存器或者对其他处理器不可见的地方，因此在读取volatile类型的变量时总会返回最新写入的值。您只能在有限的一些情形下使用 volatile 变量替代锁。要使 volatile 变量提供理想的线程安全，必须同时满足下面两个条件： 对变量的写操作不依赖于当前值。该变量没有包含在具有其他变量的不变式中。实际上，这些条件表明，可以被写入 volatile 变量的这些有效值独立于任何程序的状态，包括变量的当前状态。","tags":[{"name":"java","slug":"java","permalink":"https://koala99.github.io/tags/java/"},{"name":"多线程","slug":"多线程","permalink":"https://koala99.github.io/tags/多线程/"}]},{"title":"java gc原理","date":"2014-10-13T12:24:30.000Z","path":"2014/10/13/java gc原理/","text":"作为android开发人员，了解java的GC工作原理很有必要。我们开发的app需要不断的优化，这就包括如何优化GC的性能、如何与GC进行有限的交互。 这边就从一个简单的demo展开。在idea 运行中配置如下代码: -server -Xms10m -Xmx10m -XX:+DoEscapeAnalysis -XX:+PrintGc 这边先介绍几个概念： -Xms 10m，表示JVM Heap(堆内存)最小尺寸10MB，最开始只有 -Xms 的参数，表示 初始 memory size(m表示memory，s表示size)，属于初始分配10m，-Xms表示的 初始 内存也有一个 最小 内存的概念（其实常用的做法中初始内存采用的也就是最小内存）。 -Xmx 10m，表示JVM Heap(堆内存)最大允许的尺寸10MB，按需分配。如果 -Xmx 不指定或者指定偏小，也许出现java.lang.OutOfMemory错误，此错误来自JVM不是Throwable的，无法用try…catch捕捉。 DoEscapeAnalysis 逃逸模式，前面+代表启用，-号代表关闭 PrintGc 打印gc信息 测试代码如下： public class Test { /** * 内分配了两个字节的内存空间 */ public static void alloc(){ int[] array = new int[2]; array[0] = 1; } public static void main(String[] args) { long startTime = System.currentTimeMillis(); // 分配 100000000 个 alloc 分配的内存空间 for(int i = 0; i &lt; 100000000; i++){ alloc(); } long endTime = System.currentTimeMillis(); System.out.println(endTime - startTime); } } 可以看到跟踪的gc信息，一连串如下： [GC (Allocation Failure) 2472K-&gt;424K(9728K), 0.0030868 secs] 看起来还不够详细，可以继续配置如下命令 -XX:+PrintGCDetails，运行可以看到如下结果： [GC (Allocation Failure) [PSYoungGen: 2048K-&gt;0K(2560K)] 2488K-&gt;440K(9728K), 0.0003446 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]1832Heap PSYoungGen total 2560K, used 1515K [0x00000007bfd00000, 0x00000007c0000000, 0x00000007c0000000) eden space 2048K, 73% used [0x00000007bfd00000,0x00000007bfe7ad80,0x00000007bff00000) from space 512K, 0% used [0x00000007bff80000,0x00000007bff80000,0x00000007c0000000) to space 512K, 0% used [0x00000007bff00000,0x00000007bff00000,0x00000007bff80000) ParOldGen total 7168K, used 440K [0x00000007bf600000, 0x00000007bfd00000, 0x00000007bfd00000) object space 7168K, 6% used [0x00000007bf600000,0x00000007bf66e050,0x00000007bfd00000) Metaspace used 2991K, capacity 4494K, committed 4864K, reserved 1056768K class space used 327K, capacity 386K, committed 512K, reserved 1048576K 看最后的heap总结，这里就可以看到划分去了几个generation，PSYoungGen ParOldGen Metaspace，Metaspace，在jdk1.8中， Permanent Generation已经取代了Metaspace， young gen中就有我们熟悉的伊甸区 eden space，关于各区的介绍，这里详细的概述下： JVM在程序运行过程当中，会创建大量的对象，这些对象，大部分是短周期的对象，小部分是长周期的对象，对于短周期的对象，需要频繁地进行垃圾回收以保证无用对象尽早被释放掉，对于长周期对象，则不需要频率垃圾回收以确保无谓地垃圾扫描检测。为解决这种矛盾，Sun JVM的内存管理采用分代的策略。 1）年轻代(Young Gen)：年轻代主要存放新创建的对象，内存大小相对会比较小，垃圾回收会比较频繁。年轻代分成1个Eden Space和2个Suvivor Space（命名为A和B）。当对象在堆创建时，将进入年轻代的Eden Space。垃圾回收器进行垃圾回收时，扫描Eden Space和A Suvivor Space，如果对象仍然存活，则复制到B Suvivor Space，如果B Suvivor Space已经满，则复制到Old Gen。同时，在扫描Suvivor Space时，如果对象已经经过了几次的扫描仍然存活，JVM认为其为一个持久化对象，则将其移到Old Gen。扫描完毕后，JVM将Eden Space和A Suvivor Space清空，然后交换A和B的角色（即下次垃圾回收时会扫描Eden Space和BSuvivor Space。这么做主要是为了减少内存碎片的产生。 我们可以看到：Young Gen垃圾回收时，采用将存活对象复制到到空的Suvivor Space的方式来确保尽量不存在内存碎片，采用空间换时间的方式来加速内存中不再被持有的对象尽快能够得到回收。2）年老代(Tenured Gen)：年老代主要存放JVM认为生命周期比较长的对象（经过几次的Young Gen的垃圾回收后仍然存在），内存大小相对会比较大，垃圾回收也相对没有那么频繁（譬如可能几个小时一次）。年老代主要采用压缩的方式来避免内存碎片（将存活对象移动到内存片的一边，也就是内存整理）。当然，有些垃圾回收器（譬如CMS垃圾回收器）出于效率的原因，可能会不进行压缩。3）持久代(Perm Gen)：持久代主要存放类定义、字节码和常量等很少会变更的信息。 了解了这些，其实我们也该清楚一些优化的方法，为什么常量不宜太多，年轻区的内存空间应该大，太小了，操作频繁的数据都会进入年老区，垃圾回收不频繁。 言归正传，继续谈我们的GC，首先讲下我们的垃圾回收算法，古老的引用计数法。它的基本思想很简单，对于一个对象A，只要有任何一个对象引用了A，则A的引用计数器就加1，当引用失效时，引用计数器就减1。只要对象A的引用计数器的值为0，则对象A就不可能再被使用。就可以回收了。它的缺点也很明显，1，每次引用和去引用都需要加减，性能不行；2循环引用问题，可以看下简单代码。 class A{ public B b; }class B{ public A a;}public class Main{ public static void main(String[] args){ A a = new A(); B b = new B(); a.b=b; b.a=a; }} 这种情况下，谁都没法回收。java的垃圾回收使用的基本的算法思想是标记-清除算法： 标记-清除算法是现代垃圾回收算法的思想基础。将垃圾回收分为两个阶段：标记阶段和清除阶段。 一种可行的实现是，在标记阶段，首先通过根节点，标记所有从根节点开始的可达对象（从GC ROOT开始标记引用链——又叫可达性算法）。因此，未被标记的对象就是未被引用的垃圾对象。然后，在清除阶段，清除所有未被标记的对象。这样就不怕循环问题了。 具体效果图如下： 这种算法的缺点就是容易出现内存碎片。利用率不高。要知道，现代的Java虚拟机都是使用的分代回收的设计，比如在标记-清除算法的基础上做了一些优化的——标记-压缩算法，适合用于存活对象较多的场合，如老年代。 和标记-清除算法一样，标记-压缩算法也首先需要从根节点开始，对所有可达对象做一次标记。但之后，它并不简单的清理未标记的对象，而是将所有的存活对象压缩到内存的一端。之后，清理边界外所有的空间。有效解决内存碎片问题。 和标记-清除算法相比，复制算法是一种相对高效的回收方法，但是 不适用于存活对象较多的场合如老年代，使用在新生代， 原理是 将原有的内存空间分为两块，两块空间完全相同，每次只用一块，在垃圾回收时，将正在使用的内存中的存活对象复制到未使用的内存块中，之后，清除正在使用的内存块中的所有对象，交换两个内存的角色，完成垃圾回收。同样也没有内存 碎片产生。 复制算法的缺点是内存的浪费，因为每次只是使用了一般的空间， 而大多数存活对象都在老年代，故复制算法不用在老年代，老年代是Java堆的空间的担保地区。复制算法主要用在新生代。在垃圾回收的时候，大对象直接从新生代进入了老年代存放，大对象一般不使用复制算法，因为一是太大，复制效率低，二是过多的大对象，会使得小对象复制的时候无地方存放。还有被长期引用的对象也放在了老年代。 Java的垃圾回收机制使用的是分代的思想。 依据对象的存活周期进行分类，短命对象归为新生代，长命对象归为老年代。根据不同代的特点，选取合适的收集算法。少量对象存活（新生代，朝生夕死的特性），适合复制算法，大量对象存活（老年代，生命周期很长，甚至和应用程序存放时间一样），适合标记清理或者标记压缩算法。","tags":[{"name":"java","slug":"java","permalink":"https://koala99.github.io/tags/java/"},{"name":"垃圾回收","slug":"垃圾回收","permalink":"https://koala99.github.io/tags/垃圾回收/"}]},{"title":"lbs开发中遇到的问题","date":"2014-09-15T11:09:03.000Z","path":"2014/09/15/lbs开发中遇到的问题/","text":"在开发莫比动力中，遇到了一些问题，这边记录下，莫比动力采用的是百度地图的sdk进行定位服务，根据运动状况，记录运动轨迹。 首先必不可少遇到轨迹漂移的问题，个别轨迹漂移的问题还好解决，有时候就怕遇到长时间轨迹漂移的情况。 当个别位置漂移时，这边主要根据运动状态做了地址栅栏（在规定半径形成的圆中），如果不在此范围内，算作gps漂移，像静止状态下，速度立刻置零，而且不进行更新地图上的经纬度；运动状态时，就需要根据运动速度，首先判断速度，类似那种超大速度，超大距离的点（与速度相关），都需要过滤掉。 长时间漂移这边处理的方法，这边采用的是从第一个异常点开始计算，一定时间内，连续的出现异常点大于20这个边界值，就把这段时间的内统一清空，看做长时间漂移。 在地图上展现轨迹时，如果把记录的点直接描点连线的话，会发现基本都是很突兀的直线连接，这边就需要采用 滑动平均平滑 算法，它的实现很简单，相邻5个点一组，进行计算: 这样绘制的曲线就更加平滑了。","tags":[{"name":"lbs","slug":"lbs","permalink":"https://koala99.github.io/tags/lbs/"},{"name":"优化","slug":"优化","permalink":"https://koala99.github.io/tags/优化/"}]},{"title":"cpp的一些常见问题","date":"2014-09-10T10:52:53.000Z","path":"2014/09/10/cpp的一些常见问题/","text":"大学那会学的cpp，到现在已经很少用到了，由于12年毕业至今一直写安卓，使用的是java语言，所以淡忘了cpp里面许多的概念。这边自己来记录下。 1.一个比较经典的问题——问以下两种声明的区别： const char p 与 char const p 这个问题实质就是考察你对const的理解,const 是用于修饰常量，所以前者p是指向常量字符的指针，不变的是char的值。 后者p是一个指向字符的常量指针，不变的是p的值，即该指针不能再指向别的。 指针与引用的共同点与区别相同点，都是地址的概念。 指针指向一块内存，它的内容是所指内存的地址；引用是某块内存的别名。不同点： 指针是一个实体，而引用仅是个别名；引用使用时无需解引用（*），指针需要解引用；引用只能在定义时被初始化一次，之后不可变；指针可变； 引用没有 const，指针有 const，const 的指针不可变；引用不能为空，指针可以为空.3.深拷贝与浅拷贝简单的说，一个对象复制另一个对象，并开辟内存空间，这就叫深拷贝，如果没有开辟新的内存空间，只是类似指针指向的，就是浅拷贝4.野指针野指针是变量没有被初始化。任何指针变量刚被创建时不会自动成为NULL指针，它的缺省值是随机的，它会乱指一气。所以，指针变量在创建的同时应当被初始化，要么将指针设置为NULL，要么让它指向合法的内存。后续更新…","tags":[{"name":"日常记录","slug":"日常记录","permalink":"https://koala99.github.io/tags/日常记录/"},{"name":"cpp","slug":"cpp","permalink":"https://koala99.github.io/tags/cpp/"}]},{"title":"hashmap详解","date":"2014-08-03T13:30:30.000Z","path":"2014/08/03/java hashmap原理/","text":"hashmap在java中，我们一般面试中会经常问到:1.什么时候会使用HashMap？他有什么特点？2.你知道HashMap的工作原理吗？3.你知道get和put的原理吗？equals()和hashCode()的都有什么作用？4.如果HashMap的大小超过了负载因子(load factor)定义的容量，怎么办？ 为什么运行下面代码块： HashMap map = new HashMap(); map.put(“语文”, 1); map.put(“数学”, 2); map.put(“英语”, 3); map.put(“历史”, 4); map.put(“政治”, 5); map.put(“地理”, 6); map.put(“生物”, 7); map.put(“化学”, 8); for(Map.Entry entry : map.entrySet()) { System.out.println(entry.getKey() + “: “ + entry.getValue()); } 结果却并非我们想象的那样： 这篇文章就带你去解决这些问题。HashMap最新代码：点击查看 首先解决上面的问题，为什么排序不一致呢？看看源代码的描述。简单翻译最后一句就是：它不确保顺序。不信，你再添加元素看看运行的结果。hashmap中有两个重要的参数，容量(Capacity)和负载因子(Load factor)，容量就是hashmap的大小，负载因子就是填满的比例。再来看我们常用的put函数，添加元素，它的具体代码如下： 610 public V More …put(K key, V value) {611 return putVal(hash(key), key, value, false, true);612 }inal V More …putVal(int hash, K key, V value, boolean onlyIfAbsent,625 boolean evict) {626 Node[] tab; Node p; int n, i;627 if ((tab = table) == null || (n = tab.length) == 0)628 n = (tab = resize()).length;629 if ((p = tab[i = (n - 1) &amp; hash]) == null)630 tab[i] = newNode(hash, key, value, null);631 else {632 Node e; K k;633 if (p.hash == hash &amp;&amp;634 ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))635 e = p;636 else if (p instanceof TreeNode)637 e = ((TreeNode)p).putTreeVal(this, tab, hash, key, value);638 else {639 for (int binCount = 0; ; ++binCount) {640 if ((e = p.next) == null) {641 p.next = newNode(hash, key, value, null);642 if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st643 treeifyBin(tab, hash);644 break;645 }646 if (e.hash == hash &amp;&amp;647 ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))648 break;649 p = e;650 }651 }652 if (e != null) { // existing mapping for key653 V oldValue = e.value;654 if (!onlyIfAbsent || oldValue == null)655 e.value = value;656 afterNodeAccess(e);657 return oldValue;658 }659 }660 ++modCount;661 if (++size &gt; threshold)662 resize();663 afterNodeInsertion(evict);664 return null;665 } 具体流程，可以总结为：对key的hashCode()做hash，然后再计算index;如果没碰撞直接放到bucket里；如果碰撞了，以链表的形式存在buckets后；如果碰撞导致链表过长(大于等于TREEIFY_THRESHOLD)，就把链表转换成红黑树；如果节点已经存在就替换old value(保证key的唯一性)如果bucket满了(超过load factor*current capacity)，就要resize。再看看我们用的get方法： public V More …get(Object key) {555 Node e;556 return (e = getNode(hash(key), key)) == null ? null : e.value;557 }566 final Node More …getNode(int hash, Object key) {567 Node[] tab; Node first, e; int n; K k;568 if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp;569 (first = tab[(n - 1) &amp; hash]) != null) {570 if (first.hash == hash &amp;&amp; // always check first node571 ((k = first.key) == key || (key != null &amp;&amp; key.equals(k))))572 return first;573 if ((e = first.next) != null) {574 if (first instanceof TreeNode)575 return ((TreeNode)first).getTreeNode(hash, key);576 do {577 if (e.hash == hash &amp;&amp;578 ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))579 return e;580 } while ((e = e.next) != null);581 }582 }583 return null;584 }这代码看起来就简单多了，bucket里的第一个节点，直接命中；如果有冲突，则通过key.equals(k)去查找对应的entry若为树，则在树中通过key.equals(k)查找，O(logn)；若为链表，则在链表中通过key.equals(k)查找，O(n)。超过阀值后，我们需要进行扩容，这时就需要调用resize方法，代码如下： final Node[] More …resize() {677 Node[] oldTab = table;678 int oldCap = (oldTab == null) ? 0 : oldTab.length;679 int oldThr = threshold;680 int newCap, newThr = 0;681 if (oldCap &gt; 0) {682 if (oldCap &gt;= MAXIMUM_CAPACITY) {683 threshold = Integer.MAX_VALUE;684 return oldTab;685 }686 else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp;687 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)688 newThr = oldThr &lt;&lt; 1; // double threshold689 }690 else if (oldThr &gt; 0) // initial capacity was placed in threshold691 newCap = oldThr;692 else { // zero initial threshold signifies using defaults693 newCap = DEFAULT_INITIAL_CAPACITY;694 newThr = (int)(DEFAULT_LOAD_FACTOR DEFAULT_INITIAL_CAPACITY);695 }696 if (newThr == 0) {697 float ft = (float)newCap loadFactor;698 newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ?699 (int)ft : Integer.MAX_VALUE);700 }701 threshold = newThr;702 @SuppressWarnings({“rawtypes”,”unchecked”})703 Node[] newTab = (Node[])new Node[newCap];704 table = newTab;705 if (oldTab != null) {706 for (int j = 0; j &lt; oldCap; ++j) {707 Node e;708 if ((e = oldTab[j]) != null) {709 oldTab[j] = null;710 if (e.next == null)711 newTab[e.hash &amp; (newCap - 1)] = e;712 else if (e instanceof TreeNode)713 ((TreeNode)e).split(this, newTab, j, oldCap);714 else { // preserve order715 Node loHead = null, loTail = null;716 Node hiHead = null, hiTail = null;717 Node next;718 do {719 next = e.next;720 if ((e.hash &amp; oldCap) == 0) {721 if (loTail == null)722 loHead = e;723 else724 loTail.next = e;725 loTail = e;726 }727 else {728 if (hiTail == null)729 hiHead = e;730 else731 hiTail.next = e;732 hiTail = e;733 }734 } while ((e = next) != null);735 if (loTail != null) {736 loTail.next = null;737 newTab[j] = loHead;738 }739 if (hiTail != null) {740 hiTail.next = null;741 newTab[j + oldCap] = hiHead;742 }743 }744 }745 }746 }747 return newTab;748 }在resize的过程，简单的说就是把bucket扩充为2倍，之后重新计算index，把节点再放到新的hashmap中。现在我们就可以回答上面的问题了： 什么时候会使用HashMap？他有什么特点？是基于Map接口的实现，存储键值对时，它可以接收null的键值，是非同步的，HashMap存储着Entry(hash, key, value, next)对象。 你知道HashMap的工作原理吗？通过hash的方法，通过put和get存储和获取对象。存储对象时，我们将K/V传给put方法时，它调用hashCode计算hash从而得到bucket位置，进一步存储，HashMap会根据当前bucket的占用情况自动调整容量(超过Load Facotr则resize为原来的2倍)。获取对象时，我们将K传给get，它调用hashCode计算hash从而得到bucket位置，并进一步调用equals()方法确定键值对。如果发生碰撞的时候，Hashmap通过链表将产生碰撞冲突的元素组织起来，在Java 8中，如果一个bucket中碰撞冲突的元素超过某个限制(默认是8)，则使用红黑树来替换链表，从而提高速度。 你知道get和put的原理吗？equals()和hashCode()的都有什么作用？通过对key的hashCode()进行hashing，并计算下标( n-1 &amp; hash)，从而获得buckets的位置。如果产生碰撞，则利用key.equals()方法去链表或树中去查找对应的节点 如果HashMap的大小超过了负载因子(load factor)定义的容量，怎么办？如果超过了负载因子(默认0.75)，则会重新resize一个原来长度两倍的HashMap，并且重新调用hash方法。","tags":[{"name":"java","slug":"java","permalink":"https://koala99.github.io/tags/java/"},{"name":"hashmap","slug":"hashmap","permalink":"https://koala99.github.io/tags/hashmap/"}]},{"title":"布局标签的简单思考","date":"2013-04-11T12:19:42.000Z","path":"2013/04/11/布局标签的简单思考/","text":"一直在用用一些常用的布局标签，include,merge,viewstub，但是否真的了解其原理呢？ 首先我们用的viewstub实际上就是一个懒加载，为什么这么说呢？来看源码： public final class ViewStub extends View { ...... public View inflate() { final ViewParent viewParent = getParent(); // 1 为什么可以直接获取父视图？ // ViewStub的父视图必须是ViewGroup的子类 if (viewParent != null &amp;&amp; viewParent instanceof ViewGroup) { if (mLayoutResource != 0) { // ViewStub必须设置android:layout属性 final ViewGroup parent = (ViewGroup) viewParent; final LayoutInflater factory; if (mInflater != null) { factory = mInflater; } else { factory = LayoutInflater.from(mContext); } // 2 inflate被加载视图 final View view = factory.inflate(mLayoutResource, parent, false); if (mInflatedId != NO_ID) { view.setId(mInflatedId); } // 从父视图中获取当前ViewStub在父视图中的位置 final int index = parent.indexOfChild(this); // 当前ViewStub也是个View仅仅只是用来占位，所以先把占位的ViewStub视图删除 parent.removeViewInLayout(this); // 3 此处获取的是ViewStub上面设置的参数 final ViewGroup.LayoutParams layoutParams = getLayoutParams(); if (layoutParams != null) { parent.addView(view, index, layoutParams); } else { parent.addView(view, index); } // 目的是在复写的setVisibility方法中使用 // 因为ViewStub.setVisibility操作的是被加载视图并非当前ViewStub视图 mInflatedViewRef = new WeakReference&lt;View&gt;(view); // 调用监听 if (mInflateListener != null) { mInflateListener.onInflate(this, view); } // 返回被加载视图，如果不需要当前可以忽略此返回对象 return view; } else { throw new IllegalArgumentException(&quot;ViewStub must have a valid layoutResource&quot;); } } else { throw new IllegalStateException(&quot;ViewStub must have a non-null ViewGroup viewParent&quot;); } } ...... } 可以发现，它构造时： public ViewStub(Context context, AttributeSet attrs, int defStyleAttr, int defStyleRes) { super(context); final TypedArray a = context.obtainStyledAttributes(attrs, R.styleable.ViewStub, defStyleAttr, defStyleRes); mInflatedId = a.getResourceId(R.styleable.ViewStub_inflatedId, NO_ID); mLayoutResource = a.getResourceId(R.styleable.ViewStub_layout, 0); mID = a.getResourceId(R.styleable.ViewStub_id, NO_ID); a.recycle(); setVisibility(GONE); setWillNotDraw(true); } 首选设置需要加载的view为gone，setWillNotDraw为true，继承View.java，代表就是不绘制该布局，而我们一般的view设置为gone时，默认会加入布局绘制的，viewstub它真正绘制就是在调用了inflate()方法时，viewparent就把它加入进来。merge我们也经常用到，它起的作用也很简单，减少层级，看看主要源码: mLayout = new LinearLayout(this); mLayout.setOrientation(LinearLayout.VERTICAL); LayoutInflater.from(this).inflate(R.layout.merge_tag, mLayout); setContentView(mLayout); 另外我们经常会加一个空格空间，经常的做法就是一个没有文字的textview来做，，这样它会参与视图的绘制，实际上我们可以用Space来做，看他的源码可以发现，它的ondraw方法为空，确实很轻量级。","tags":[]},{"title":"activity的一些生命周期场景","date":"2012-09-11T12:37:35.000Z","path":"2012/09/11/activity的一些生命周期场景/","text":"1，进入Activity onCreate -&gt; onStart -&gt; onResume2，BACK键 onPause -&gt; onStop -&gt; onDestroy3，HOME键 Home键退出：onPause -&gt; onStop Home键回来：onRestart -&gt; onStart -&gt; onResume4，休眠/恢复 休眠：onPause 恢复：onResume5，旋转屏幕 未设置android:configChanges： onPause -&gt; onStop -&gt; onDestory -&gt; onCreate -&gt; onStart -&gt; onResume设置了android:configChanges=”orientation| keyboardHidden”：不会触发生命周期方法.6，来电 来电，显示来电界面：onPause -&gt; onStop 关闭电话界面，重新回到当前Activity：onRestart -&gt; onStart -&gt; onResume 7,其他Activity 进入下一个Activity： A.onPause -&gt; B.onCreate -&gt; B.onStart -&gt;B.onResume -&gt; A.onStop 从其他Activity返回至当前Acitivity： onRestart -&gt; onStart -&gt; onResume 与Activity生命周期结合的应用场景3.1 与广播(Broadcast)结合 在onResume注册广播(registerLinstener)，在onPause注销广播(unregisterLinstener)。 例如： 做”摇一摇”功能（传感器）、监听网络变化，就可以在onResume中注册监听，在onPause里注销掉，已节省资源提高效率。 3.2与服务(Service)结合 在onStart绑定服务(bindService)，在onStop中取消绑定(unbindService)。 例如： 需要通过Service定时更新UI上的数据，而Activity的可见周期在onStart与onStop之间，那么就可以再onStart时启动服务，在onStop时停止服务。为了节约系统资源，除了提高用户体验以外，开发人员应尽可能的优化程序。 3.3 与Cursor结合 使用managedQuery让Activity帮你管理Cursor的生命周期，不用自己去close。 3.4 释放资源 可以在onDestory中释放一些资源。比如可以在onDestory时调用MediaPlayer的release。","tags":[]}]